#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Game Engine Design
\end_layout

\begin_layout Standard
The focus on the design of the game engine have been on making it as generic
 as possible, and we have been careful not to tie it to GOAL or EIS.
 Instead of directly using EIS data types, we have implemented support for
 converters, which convert percepts and actions to and from foreign data
 types.
 An agent in the game engine is an entity capable of performing actions
 and gathering percepts.
 An agent controller is connected to an agent and knows how to receive actions
 and send percepts to an environment.
 
\end_layout

\begin_layout Section
GOAL and asynchronous agents
\end_layout

\begin_layout Standard
We have designed our game engine so that all agents have a thread of their
 own, meaning they can perform actions and receive percepts independent
 of other agents' states.
 This allows for a more fluently running game, as agents do not stop and
 start actions in synchronization.
 It also means that the properties of agents can be more fine grained, eg.
 an agent's speed can be given as an integer indicating the milliseconds
 it takes to move from one tile to another.
 GOAL, however, seems to be designed to run all agents sequentially in a
 single thread, which means that if a single agent blocks in the call to
 get all its percepts from the environment (because the environment only
 returns when the agentâ€™s current action is fully performed), no other agents
 can continue execution until the call returns.
 One way to circumvent this is to use durative actions (as explained in
 the GOAL user manual).
 With this method an ongoing action is started through GOAL, and in each
 percept cycle GOAL evaluates whether the agent should continue executing
 the action or choose another.
 The problem with this approach is that we are effectively polling the environme
nt through GOAL; the agent may not have any new information in each percept
 cycle, and it may sit idle, waiting for the next percept cycle when it
 has finished the action.
 In order to have a more dynamic, responsive and efficient system, we have
 chosen to launch a GOAL environment for each agent.
 This means that the agents will have to share communicate through the environme
nt.
\end_layout

\end_body
\end_document
