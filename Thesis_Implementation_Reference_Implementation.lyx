#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Reference Implementation
\begin_inset CommandInset label
LatexCommand label
name "sec:ImplementationReferenceImplementation"

\end_inset


\end_layout

\begin_layout Standard
The reference implementation relies heavily upon the extensions that are
 attached as part of the engine.
 Thus to see how the reference implementation was designed we would refer
 to look at those extensions.
\end_layout

\begin_layout Standard
The extensions the reference implementation uses:
\end_layout

\begin_layout Description
Logger
\begin_inset space ~
\end_inset

Extension this is used to log all actions that occur inside the engine and
 to log any errors that might also occur.
\end_layout

\begin_layout Description
EIS
\begin_inset space ~
\end_inset

Extension this extension is used to connect the reference implementation
 to our goal program for the agents inside the reference implementation.
\end_layout

\begin_layout Description
Tile
\begin_inset space ~
\end_inset

World
\begin_inset space ~
\end_inset

Extension the reference implementation uses a Tile based world as such it
 directly uses the Tile World Extension that provides just this functionality.
\end_layout

\begin_layout Standard
The reference implementation as such only provides:
\end_layout

\begin_layout Itemize
Actions specific to the reference implementation(Grabbing/releasing packages)
\end_layout

\begin_layout Itemize
Entities specific to the reference implementation(Walls, Player, etc.)
\end_layout

\begin_layout Itemize
Percepts and modules specific to the reference implementation(Holding package
 percept)
\end_layout

\begin_layout Itemize
A view in console form
\end_layout

\begin_layout Itemize
A Goal program
\end_layout

\begin_layout Itemize
A way to control an agent with keyboard
\end_layout

\begin_layout Subsection
The Console View
\end_layout

\begin_layout Standard
The console view is designed is optimized to draw the screen at a specific
 frame rate.
 When the console view does not draw it will instead update all view data
 is has stored.
\end_layout

\begin_layout Standard
To change view data in a view, an event must be fired from the model, however
 since the model is operating on a different thread than the view.
 The view must ensure no concurrent errors.
 This is done by using the 
\family typewriter
ThreadSafeEventMananger
\family default
, as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "ImplementationView"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename ConsoleViewDrawingFlowChart.png
	width 40text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
the sequence of the console view drawing process
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The console view works by drawing the screen, then if it has time between
 left before the next drawing is scheduled the view will execute a single
 event on the 
\family typewriter
ThreadSafeEventManager
\family default
.
 The view will continue this process until either, there is no events left
 to be executed or the time is up and it is time for it to perform the next
 drawing of the screen.
 On fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "FlowOfConsole"

\end_inset

 a drawing of this process can be seen.
\end_layout

\begin_layout Standard
This provides the reference implementation with a very quickly updated view
 as no time is wasted on the thread and instead will continue to update
 even when it is not drawing.
 Furthermore by updating the view data in a separate thread the engine core
 does not use its computation power on handling this making the engine overall
 more efficient.
\end_layout

\begin_layout Subsection
GOAL Program Implementation
\end_layout

\begin_layout Standard
The goal program is designed to work directly with our reference implementation,
 as it is just a show case of how such a program might look like, it will
 make assumptions based on how the reference implementation interact.
 For instance it will assume that there are entities called walls that are
 meant to block off tiles.
 
\end_layout

\begin_layout Standard
To see the source code of our goal program commented, look in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "GoalCodeAppendix"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Agent Decision
\end_layout

\begin_layout Standard
A full flow chart of the goal program decision chart can be found on appendix
 
\begin_inset CommandInset ref
LatexCommand ref
reference "GOALFlowChartAppendix"

\end_inset

.
\end_layout

\begin_layout Standard
As can be seen from the flow chart, the agent will try and find packages
 and bring them to a dropzone, if no such packages can be found or if no
 dropzone is found, the agent will start exploring the entire world.
\end_layout

\begin_layout Standard
The goal program operates with a few different notions; 
\end_layout

\begin_layout Description
Street the first notion is the notion of streets.
 A tile is a street if it contains no wall types such a normal walls or
 impassableWalls(map boundaries walls) this means that the agent can move
 on this tile.
\end_layout

\begin_layout Description
Route all the agents decisions are preplanned this means that the agent
 determines where to move to, this plan is put into a route, the agent will
 follow this route whenever it has nothing else to do, such as grabbing/releasin
g packages.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename VisionExploredGOALAgent.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An image of an agent’s vision and which it would determine to be explored
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Explored the agent’s goal is to eventually have all tiles explored as this
 means that all packages has been collected from the world.
 The agent determines that a tile has been explored if it has seen all its
 adjacent tiles.
 This works great for the agent because until it reaches a wall the unexplored
 tiles that it has stored as a street will always be considered unexplored,
 no matter how far it moves, this makes the agent work much like putting
 a carrot in front of a mule, no matter how much the agent explores whenever
 it explores something, there is always something new that becomes unexplored.
 As such this will continue until a wall has been reached on all its paths.
 
\begin_inset Newline newline
\end_inset

A tile is determined to be explored if all tiles adjacent to has been seen
 by the agent, fig.
 VisionExploredGoalAgent shows an image of this.
\end_layout

\begin_layout Subsection
Interfacing with GOAL and EIS
\end_layout

\begin_layout Standard
As mentioned in previous sections, all agents in the XMAS engine execute
 asynchronously in their own thread.
 GOAL, however, seems to be designed to run all agents sequentially in a
 single thread, which means that if a single agent blocks in the call to
 get all its percepts from the environment (because the environment only
 returns when the agent’s current action is fully performed), no other agents
 can continue execution until the call returns.
 One way to circumvent this is to use 
\emph on
durative actions
\emph default
 (as explained in the GOAL user manual).
 With this method an ongoing action is started through GOAL, and in each
 percept cycle GOAL evaluates whether the agent should continue executing
 the action or choose another.
 The problem with this approach is that we are effectively polling the environme
nt through GOAL; the agent may not have any new information in each percept
 cycle, and it may sit idle, waiting for the next percept cycle when it
 has finished the action.
 
\end_layout

\begin_layout Standard
In order to have a more dynamic, responsive and efficient system, we have
 chosen to launch a GOAL environment for each agent.
 This means -- as mentioned in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:ReferenceImplementation"

\end_inset

 -- that the the agents cannot communicate through GOAL, since the instances
 have no knowledge of each other.
 To remedy this, a communicative action should be provided by the XMAS engine.
\end_layout

\begin_layout Subsection*
Summary
\end_layout

\begin_layout Standard
The reference implementation was designed as a reference for all the features
 of the engine, as such it made heavily use of the extensions that we implemente
d.
 This section only covered the view and the goal program in details.
 This is because most of the reference implementation consists of either
 declaring new agent/entity types or wiring all the extensions together,
 as such there was almost no business logic involved which makes them rather
 uninteresting to explain in detail.
\end_layout

\begin_layout Standard
One part that the reference implementation does not cover which could have
 been interesting was the notion of linked module as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "SysFeatEntities"

\end_inset

.
 This could have been used in the reference implementation but we did not
 choose to do so.
\end_layout

\begin_layout Standard
Overall the design of the reference implementation is very solid and fulfills
 the goals we had for it, which were to be a showcase for our engine.
\end_layout

\end_body
\end_document
