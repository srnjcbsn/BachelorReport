#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 4
\tocdepth 4
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
There are many complications when developing multi agent systems, our goal
 with this project was to lessen one of these by designing an engine with
 the specific purpose to develop multi agent environments.
 What these environments can be is left to the developer, however almost
 everything in the engine is modular and interchangeable ensuring that all
 types of multi agent environments are possible.
 
\end_layout

\begin_layout Standard
What the types of projects can be is manifold but here are some possible
 examples
\end_layout

\begin_layout Paragraph*
Agent comparison software 
\end_layout

\begin_layout Standard
There are many complications when developing multi agent systems, our goal
 with this project was to lessen one of these by designing an engine with
 the specific purpose to develop multi agent environments.
 What these environments can be is left to the developer, however almost
 everything in the engine is modular and interchangeable ensuring that all
 types of multi agent environments are possible.What the types of projects
 can be is manifold but here are some possible examples
\end_layout

\begin_layout Standard
For instance if two groups wanted to test their agent programs against each
 other this engine would make it possible for them to easily design a world
 in which this test could occur.
\end_layout

\begin_layout Paragraph*
Agent testing/Simulation software
\end_layout

\begin_layout Standard
Testing agent software can be complicated being able to rapidly create an
 environment and visualize it can be important to the project as it ensure
 basic mistakes are ironed out before larger scale implementation.
 
\end_layout

\begin_layout Paragraph*
Agent teaching tools
\end_layout

\begin_layout Standard
Teaching agent languages can be tough without proper exercises; however
 the time spent on designing these exercises can prove too exhausting for
 the teacher to develop.
 In this case the teacher can rapidly design the world he had in mind for
 his exercise instead of designing every integral part of the multi agent
 system himself.
 This is because our engine provides all the basic features of a multi agent
 system, so that the time can be spent more productively on designing how
 a given exercise should play out, show casing the problem the students
 are supposed to deal with.
\end_layout

\begin_layout Paragraph*
Computer games
\end_layout

\begin_layout Standard
In theory most computer games are just multi agent programs where one of
 the agents is controlled by the player.
 Our engine should make it fairly easy for setting up a framework for creating
 rules inside a given world and ensure that the agents of the world follow
 said rules.
\end_layout

\begin_layout Section
Theory
\end_layout

\begin_layout Subsection
Model View Controller
\end_layout

\begin_layout Standard
To ensure that code is correctly decoupled from one another strict design
 patterns are necessary, these allow for developing complex projects without
 losing the sight of the entire project.
 If no pattern is followed then code can easily become so entangled that
 later development might prove impossible.
 This section will cover all the rules and ideas behind the Model-View-Controlle
r design pattern shortened MVC.
\end_layout

\begin_layout Standard
The MVC pattern principle is that programs that can be interacted with a
 user can be split into three different components.
 The three components are as follows:
\end_layout

\begin_layout Itemize
Model -- Core of the program
\end_layout

\begin_layout Itemize
View -- Visualization of the program
\end_layout

\begin_layout Itemize
Controller -- Manager of state changes to the core of the program
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename MVC.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MVCBasic"

\end_inset

This image shows how the three components are connected to each other; the
 full arrows indicate that a component has complete knowledge of the component
 it is pointing to.
 A stripped arrow indicates that the component the stripped arrow is pointing
 to is listening to the component the arrow is originating from.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Model
\end_layout

\begin_layout Standard
The model is the core of the program it is why the program functions as
 it does, it contains all information of the data and it is here all business
 logic is located.
 The model should have no knowledge of either the view or the controller,
 thus by not knowing either the program is ensured to not be tainted by
 their influence.
\end_layout

\begin_layout Standard
While may not know of the view or controller it is paramount that the model
 is built to optimally transfer information concerning its current state.
 That means putting in a way in the model for other components to listen
 to it is very welcome.
 Commonly this is referred to as events in most programming languages, what
 this does for the model is that in the case that model state has been altered
 it will have a way to provide the information of the state.
 If such features are not built into the model then it would require the
 component changing the state to inform of the state changes, in case of
 a MVC design.
 The component changing state is the controller and such the controller
 would both have the duty of changing the state and maintaining the view.
 This is generally the case of a badly designed model and can be completely
 avoided if the model simply has the ability to inform its listeners of
 any changes.
\end_layout

\begin_layout Subsubsection
View
\end_layout

\begin_layout Standard
The view is a way to visualize what is currently occurring inside model
 by visualizing it to the user, a view may take many shapes depending on
 the model.
 For instance if the model is a program calculating data on a server, then
 the view could take the form of a logging console.
 Or if the model was a computer game then the view would be the graphic
 representation of the game.
 Generally a view should only have knowledge of the model and not the controller
, the idea is that if the model data is complete then interaction with the
 controller should not be necessary.
\end_layout

\begin_layout Standard
When designing a view there are some common pitfalls that happen easily
 if one is not careful of the design.
 First off the view is what it is named; a view this means that it should
 never do any state changes to the model.
 If getting hold of data means that the model must change its state to accommoda
te this then the model is poorly made and should be changed.
 However a view is allowed to change its own state without involving either
 the controller or model.
 To fully understand what is meant by this is easily understood with an
 example:
\end_layout

\begin_layout Standard
Assume you have a menu bar as depicted in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:menubar"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename MenuBar.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:menubar"

\end_inset

A standard menu bar.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To open a menu, the user need to drag the mouse and click on one menu he
 or she wishes to open.
 However in this case many would confuse this to be the task of the controller.
 It is not since the changes done are only performed on the views own state
 and not the model of the program, thus it allowed to be its own controller.
\end_layout

\begin_layout Subsubsection
Controller
\end_layout

\begin_layout Standard
The controller is link between the model and the user, by convention all
 changes the user wish to do on the model should be done through controller.
 Like the view it can take many shapes, to name a few be that the controller
 directs the input from a mouse in a way that affect the model, however
 it could also be a controller that controls how a network data stream has
 effect on the model.
 
\end_layout

\begin_layout Standard
In a well-designed program the controller should never have to interact
 with the view, however this can be practically impossible on larger projects
 unless carefully planned and as such the controller by convention is allowed
 to know of both the view and the model.
\end_layout

\begin_layout Standard
A common mistake when designing the controller is to mistake the unit which
 the controller gets input from as the actual controller.
 In many cases the keyboard is the device from which input is transformed
 into state changes to the model, however that does not mean that the controller
 should be the only unit interacting with the keyboard.
 Going back to the example used to understand the view, the reason why controlle
r should not deal with opening a menu bar on the view is because the controller
 is not responsible on the state of the view.
 The controller is only responsible for the state of the model; the only
 case in which it is allowed for the controller to interfere with the view
 is in the case that the model was unsuccessful in properly informing about
 its state change caused by the controller.
 In this case it is okay for the controller to call the view and ask it
 to adjust itself.
 
\end_layout

\begin_layout Standard
The reasoning for why the controller is normally mistaken to be responsible
 for handling changes to the state of the view is because it is mistakenly
 thought of as a controller for the entire program and not the model, a
 view may contain its own controller which should not be mistaken from the
 other controller, to fully understand this imagine that the view in itself
 also contains a MVC inside itself (see fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MVCeption"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename MVCeption.png
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MVCeption"

\end_inset

A view with a MVC inside of it.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The model of a view such as a menu bar would contain data about the names
 of the menus and it would be responsible for ordering and accessing information
 as to what each menu contains.
 Its view would be that of a drawing board responsible for properly drawing
 the menu bars.
 Luckily most views are simple so one does not need to make an entire MVC
 design, but for graphical user interface used in most operating system
 it is very important to understand that a view can be an entire MVC setup
 in itself, this is why most operating system comes with libraries to easily
 design GUI.
\end_layout

\begin_layout Section
Reference Implementation
\end_layout

\begin_layout Standard
To showcase and test our engine, we have used it to create a simple environment
 with a tile based world.
 In this world, agents are tasked with finding packages in a maze and dropping
 them at a tile containing a 
\family typewriter
dropzone
\family default
 (see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:maze-scrot"

\end_inset

).
 Agents are controlled by separate GOAL instances with an EIS environment,
 which communicates with the XMAS engine via XML messages passed over sockets.
 The agent programs catalogue the tiles they can see and uses A* search
 to find paths to packages and the dropzone.
 The actions available to an agent are listed below.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename TileWorldColoredScrot.png
	width 20text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An initial configuration of the package grabber scenario.
 
\family typewriter
D
\family default
 (red) marks the dropzone, 
\family typewriter
X
\family default
s (green) are packages, 
\family typewriter
A
\family default
s (black) are agents and 
\family typewriter
W
\family default
s (grey) are walls
\begin_inset CommandInset label
LatexCommand label
name "fig:maze-scrot"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
move(
\emph on
Direction
\emph default
)
\family default
 moves the agent one tile in the specified 
\family typewriter
\emph on
Direction
\family default
\emph default
.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
grab
\family default
 removes the package in the same tile as the agent (if any) from the world,
 and marks the agent as carrying a package.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
drop
\family default
 adds a package to the world in the same tile as the agent (if it is carrying
 a package) and marks the agent as not carrying a package.
\end_layout

\begin_layout Standard
Additionally, we plan to implement a messaging action, allowing the agents
 to communicate with each other.
 This is particularly necessary when using GOAL, as the GOAL instances have
 no knowledge of each other and thus cannot use the messaging system built
 into GOAL.
\end_layout

\begin_layout Section
System Features
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
The goal of the engine is to allow for simulation of a world where agents
 within are allowed to act, as such what is important for this is that it
 can accurately model a state-machine.
 To model a state-machine one must have the ability to save a state and
 perform actions to change the current state.
 
\end_layout

\begin_layout Subsubsection
State
\end_layout

\begin_layout Standard
In our domain model we have state stored in three object types:
\end_layout

\begin_layout Itemize
World
\end_layout

\begin_layout Itemize
Entities
\end_layout

\begin_layout Itemize
Modules
\end_layout

\begin_layout Paragraph*
World
\end_layout

\begin_layout Standard
The world is the place where all entities are meant to inhabit as either
 agents of the world or simply objects for the entities to interact with.
 The world is not defined by us as shown on the domain uml it is an abstract
 class meaning it is the developer using our engine that defines the world.
 As such the world can be any type of world needed, it could be a 3-d world,
 a 2-d world, a world based on tiles or hexagons or simply be nodes with
 an undefined number of edges connecting each other.
\end_layout

\begin_layout Paragraph*
Entities
\end_layout

\begin_layout Standard
The world is empty without anything inside it as such we have the entities
 which are meant to model the objects one would have the world to contain.
 For example in our reference implementation using our engine, we have a
 maze with packages scattered about.
 It is then the task of the agents to collect these packages; the entities
 here are not only the walls of the maze and the packages but also the agents
 since they inhabit the world as well.
 The agents are different from entities in the way that they all have a
 name this name is unique and is meant to be a way of distinguishing the
 agents from one another.
 
\end_layout

\begin_layout Paragraph*
Modules
\end_layout

\begin_layout Standard
The modules can be viewed as the constraints and as the abilities of all
 entities.
 For instance if you wanted to constrain entities from moving into each
 other than you would create a Movement blocking module, this module would
 then contain information on whether or not a given entities is allowed
 to pass it.
 
\end_layout

\begin_layout Subsubsection
Actions
\end_layout

\begin_layout Standard
A world is static and unexciting if one is not allowed to perform any changes
 to it, for this we have what we have chosen to name actions.
 There are two different kinds of action types there are environment actions
 and there are entity actions the core difference between them is that entity
 actions are meant as actions a single entity performs such as moving the
 entity or having the entity pick up another object.
 Environment actions are actions that affect the entire world.
 In our domain model we have chosen to add two actions that are built into
 the engine, the first is an entity action that gets all the percepts for
 a given entity called 
\family typewriter
GetallPerceptsAction
\family default
 and the other is an environment action that can shut down the engine called
 
\family typewriter
CloseEngineAction
\family default
.
 
\end_layout

\begin_layout Subsubsection
Events and Triggers
\end_layout

\begin_layout Standard
The engine relies heavily upon events, this means that all actions performed
 within the engine is meant to trigger events in responds.
 This can be used to either activate new actions within the engine, or be
 meant to transfer data to the views listening.
 
\end_layout

\begin_layout Standard
In order to listen to the events, a trigger need to be created with all
 the events it listens to registered to it.
 Furthermore a trigger needs a condition and an action, the condition is
 a predicate that determines whether the trigger is fired, the action is
 the function that is fired.
\end_layout

\begin_layout Subsection
Virtual World
\end_layout

\begin_layout Standard
The object used to keep track of all entities in the environment is called
 the 
\emph on
world
\emph default
.
 This object is also used to model the structure of the environment; eg.
 whether it is tile based, graph based or something else entirely.
 The only restriction imposed on the structure of the environment is that
 all entities have an associated 
\emph on
position
\emph default
 in it, fitting the data structure describing the environment.
 This is a pretty loose requirement, considering that it can effectively
 be ignored 
\family typewriter
\emph on
[could any meaningful environment be constructed where position doesn't
 matter?]
\end_layout

\begin_layout Standard
In a tile based environment, for example, the world could consist of a two
 dimensional array containing lists of entities, with each field representing
 a tile, and positions represented as 
\begin_inset Formula $(x,y)$
\end_inset

 coordinates.
 In a graph based environment, the world would contain some structural represent
ation of a graph, and the positions could be references to nodes, or representat
ions of the graph as seen from different nodes.
 
\family typewriter
\emph on
[More detailed usage examples?, Tile Extension]
\end_layout

\begin_layout Subsubsection
Entities, Agents and Entity Modules
\end_layout

\begin_layout Standard
Entities are the objects inhabiting the world.
 They are very basic objects, equipped with no definitions of how they are
 represented in the world or how they can be interacted with, save for allowing
 other objects to subscribe to events propagated 
\family typewriter
\emph on
[fired?]
\family default
\emph default
 by the entity.
 All this is instead handled by 
\emph on
entity modules
\emph default
, which each entity contains a set of.
 These modules can be queried and called by other objects.
\end_layout

\begin_layout Standard
In our reference implementation, package grabber agents have the 
\emph on
package
\emph default
 module keeping track of whether or not they hold a package.
\end_layout

\begin_layout Standard
When modules are asked to identify themselves, they do so by means of a
 
\emph on
module type
\emph default
.
 It is perfectly legal (and sometimes recommended) for a module to identify
 itself by another type.
 If an effect would, for example, reduce an entity's movement speed by 
\begin_inset Formula $50\%$
\end_inset

, it is recommended practice to register a new module to the entity, which
 identifies itself as a speed module.
 Since the entity contains a set of modules, there would be no ambiguity,
 as the new module would replace the original.
 Additionally, when the new module is registered to the entity, it checks
 to see if any modules with the same type is already attached.
 If that is the case, it stores a reference to the original, and re-attaches
 it when it is itself detached.
 This allows for using filter modules, which could -- in the speed modification
 example -- query the stored module for its speed value 
\begin_inset Formula $s$
\end_inset

, and then return 
\begin_inset Formula $\tfrac{s}{2}$
\end_inset

.
 If several effects are applied to a property, this would function like
 a chain 
\end_layout

\begin_layout Standard
An 
\emph on
agent
\emph default
 is a special entity which have a unique name and can collect percepts.
 When an agent is asked to return all of its percepts, it queries each module
 for any available percepts, and returns those as a collection.
 
\family typewriter
\emph on
[move this paragraph up (and rewrite?)]
\end_layout

\begin_layout Subsection
Events and Triggers
\end_layout

\begin_layout Standard
In this part the concept and idea of both events and triggers.
 We will go through their intention and how to use them when using the engine,
 furthermore a couple of example will be shown in order to give the general
 idea of what they can be used for.
 
\end_layout

\begin_layout Subsubsection
Concept
\end_layout

\begin_layout Standard
In this part the concept and idea of both events and triggers.
 We will go through their intention and how to use them when using the engine,
 furthermore a couple of example will be shown in order to give the general
 idea of what they can be used for.
 
\end_layout

\begin_layout Paragraph*
Events
\end_layout

\begin_layout Standard
To be clear an Event when speaking in the context of this engine is the
 occurrence of something, for instance an Event could be that “an Agent
 has moved”, or “an Agent has picked up an item”.
 Furthermore an event also has the duty of providing necessary information
 for the listener giving the listener a correct idea of the meaning behind
 an event.
 Going back to the Event of an Agent that has moved, in this case it necessary
 to provide the listener 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Listeners refer to the object which is listening to the occurrence of an
 event, with the intent of reacting to it
\end_layout

\end_inset

 with information of which direction the agent moved, where its starting
 position is and how far it has moved.
 Since a listener might be operating in a different thread, the listener
 is completely dependent on this information as it might no longer be retrievabl
e at the time the event is being analyzed.
 For instance if an agent moved and then was killed and removed from the
 world, its position would no longer be stored in the world.
 As such the listener would have no way to determine where the move had
 ended if not provided in the event.
\end_layout

\begin_layout Paragraph*
Triggers
\end_layout

\begin_layout Standard
Triggers in our engine are the means to which listeners gain access to events.
 A trigger in our engine is the combination of three different parts.
\end_layout

\begin_layout Itemize
Events
\end_layout

\begin_layout Itemize
Condition
\end_layout

\begin_layout Itemize
Action
\end_layout

\begin_layout Description
The
\begin_inset space ~
\end_inset

events are what the Trigger is listening for these can be any type of event,
 furthermore a trigger can be registered to any number of events.
 But only one event is required to “trigger” a Trigger for instance if a
 Trigger is listening on the event “10 seconds passed” and the event “Agent
 has moved”, then if either of the event has occurred the Trigger will be
 “triggered”.
 However it will be triggered each and every time such event has occurred
 and is not limited to just one occurrence.
\end_layout

\begin_layout Description
The
\begin_inset space ~
\end_inset

Condition is a built in predicate for the trigger to check if it is willing
 to respond to the event.
 If the condition is satisfied the trigger’s action is fired.
 A condition should only be used in cases that is not covered by another
 event.
 For instance, say you have the event “An agent has moved”.
 Let us call the agent that moved 
\begin_inset Formula $a_{m}$
\end_inset

 and the agent whose movement you are interested in 
\begin_inset Formula $a_{i}$
\end_inset

.
 The condition on the trigger would then be: 
\begin_inset Formula 
\[
\textrm{\textbf{is }}a_{m}=a_{i}\textbf{ ?}
\]

\end_inset


\begin_inset Newline newline
\end_inset

As we can see the condition narrows the range of events that are responded
 to at the cost of added calculations.
 In this case it would be much better to subscribe to the event “Agent 
\begin_inset Formula $a_{i}$
\end_inset

 has moved”, this purely an example as events should of course not be tied
 to specific objects.
 
\family typewriter
\emph on
[Make better example, explain why it is not feasible tie events to specific
 objects]
\end_layout

\begin_layout Description
The
\begin_inset space ~
\end_inset

Action of a trigger is meant as the one that performs the work, it is a
 mere method which is executed once an event has been raised and the condition
 is satisfied.
 For instance if a trigger is meant to write a message when a specific event
 has occurred then this is where the action of writing such message should
 be placed.
\end_layout

\begin_layout Subsubsection
Entities and 
\family typewriter
EventManager
\end_layout

\begin_layout Standard
For triggers to become part of the engine it is required that the trigger
 is registered to the engine, however it is crucial what one registers the
 trigger to.
 A trigger can be registered to either a specific entity or the 
\family typewriter
EventManager
\family default
.
 A Trigger registered to the 
\family typewriter
EventManager
\family default
 will be triggered each an 
\family typewriter
Event
\family default
 that it is listening to is fired.
 However a 
\family typewriter
Trigger
\family default
 registered to a specific entity, will only be informed of events raised
 on the specific entity instead of when the event is raised for every single
 entity.
 
\end_layout

\begin_layout Standard
An example of this would be: assume you have a Trigger 
\family typewriter

\begin_inset Formula $\mathtt{T_{1}}$
\end_inset


\family default
 with the event “An agent has moved”, and 
\family typewriter

\begin_inset Formula $\mathtt{T_{1}}$
\end_inset


\family default
 is registered to Agent 
\family typewriter
A
\family default
, also in this example you have a Trigger 
\family typewriter

\begin_inset Formula $\mathtt{T_{2}}$
\end_inset


\family default
 with same event as 
\family typewriter

\begin_inset Formula $\mathtt{T_{1}}$
\end_inset


\family default
 but this trigger is registered to the EventManager.
 To give a complete picture also assume there is an Agent 
\family typewriter
B
\family default
 which has no Triggers registered to it.
\end_layout

\begin_layout Standard
This provides us with two scenarios:
\end_layout

\begin_layout Description
Agent
\begin_inset space ~
\end_inset


\family typewriter
A
\family default

\begin_inset space ~
\end_inset

has
\begin_inset space ~
\end_inset

moved: In this case, both 
\family typewriter

\begin_inset Formula $\mathtt{T_{1}}$
\end_inset


\family default
 and 
\family typewriter

\begin_inset Formula $\mathtt{T_{2}}$
\end_inset


\family default
 is triggered, since 
\family typewriter

\begin_inset Formula $\mathtt{T_{1}}$
\end_inset


\family default
 listens on Agent 
\family typewriter
A
\family default
 and 
\family typewriter

\begin_inset Formula $\mathtt{T_{2}}$
\end_inset


\family default
 listens to any
\family typewriter
 
\family default
agent moving.
\end_layout

\begin_layout Description
Agent
\begin_inset space ~
\end_inset


\family typewriter
B
\family default

\begin_inset space ~
\end_inset

has
\begin_inset space ~
\end_inset

moved: In this case, only 
\begin_inset Formula $\mathtt{T_{2}}$
\end_inset

 is triggered, for the reasons stated above.
\end_layout

\begin_layout Subsubsection
Example of making and using an 
\family typewriter
Event
\end_layout

\begin_layout Standard
Let’s assume one was to make an event which was fired each time an agent
 had moved, let us name this Event: 
\family typewriter
AgentMoved
\family default
.
\end_layout

\begin_layout Standard
First, make a class extending the 
\family typewriter
XmasEvent
\family default
 class as shown below:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename XmasEventCreationStepOne.png

\end_inset


\end_layout

\begin_layout Standard
Then, add all the necessary data fields on the newly created event class.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename XmasEventCreationStepTwo.png

\end_inset


\end_layout

\begin_layout Standard
To utilize the newly created event it must be raised when appropriate.
 In this case the appropriate place would be to raise it during a move action.
\end_layout

\begin_layout Standard
In this action after the movement of the agent had been performed the method
 
\family typewriter
RaiseEvent
\family default
 would need to be called on the Agent Entity itself that is being moved.
\end_layout

\begin_layout Subsubsection*
Summary
\end_layout

\begin_layout Standard
Events are what provides the engine flexibility and allows making reactions
 to others actions, events are designed for easy use and are meant to be
 used as much as possible.
 Triggers are used as a way to interface with the Events and they are the
 only way to connect an object to the event it wishes to listen to.
\end_layout

\begin_layout Subsection
Actions
\end_layout

\begin_layout Standard

\family typewriter
XmasAction
\family default
s in the UML Domain model diagram refers to a the object type that performs
 actions inside the engine, the reasoning behind these actions being its
 own class is to ensure only one action at a time is being performed this
 is because there are many separate threads operating on the model code
 at once and as such there must be a way to active only one action at a
 time.
\end_layout

\begin_layout Standard
For the task of executing the actions we have the 
\family typewriter
ActionManager
\family default
.
 Its job is to take in one action at a time and place them in a queue (see
 fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ActionQueuing"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ActionQueuing.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ActionQueuing"

\end_inset

Sequence diagram illustrating how a 
\family typewriter
MoveEntityAction
\family default
 is processed.
 The idea is that a controller, such as keyboard input or an agent language
 queues an action such as moving an entity on the action manager, the action
 manager will then execute the action as soon as it is ready.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Action Types
\end_layout

\begin_layout Standard
The engine is featured with two different action types, one is an Environment
 Action, and this action type is meant to reflect actions that do changes
 to the entire environment.
 The can be actions such as closing this engine or adding/removing entities
 from the world.
\end_layout

\begin_layout Standard
The other action type is an 
\family typewriter
EntityAction
\family default
.
 this action type is meant as an action that a single entity performs; ideally
 the actions should be as atomic as possible.
 In our reference implementation we have given some ideas how these actions
 work such as grab which is an action that grabs a package from below an
 agent.
\end_layout

\begin_layout Subsubsection
Example -- Move Entity Action
\end_layout

\begin_layout Standard
To give an idea of how an entity action is made by inheriting the 
\family typewriter
EntityAction
\family default
 class.
 As shown in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MoveEntityActionExample"

\end_inset

, we have created a 
\family typewriter
MoveEntityAction
\family default
 class with one field containing the direction of the move.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename MoveEntityActionExample.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MoveEntityActionExample"

\end_inset

 MOAR TEEEXT!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To make so the action performs something it is required that an abstract
 method Execute is implemented this execute method is the method that is
 executed by the action manager.
 The implementation of the execute action could then look something like
 the following pseudo code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

method Execute returns nothing 
\end_layout

\begin_layout Plain Layout

    NewPosition = GetPositionOf(World, This.getSource()) + Direction 
\end_layout

\begin_layout Plain Layout

    Wait(MOVE_TIME) 
\end_layout

\begin_layout Plain Layout

    SetPositionOf(World,This.getSource(), NewPosition) 
\end_layout

\begin_layout Plain Layout

EndMethod
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As one can see the idea would be that you find the position of the source
 of the 
\family typewriter
EntityAction
\family default
 and use that to generate a new position which is its old position incremented
 by its direction vector.
 The wait is there to give the move a speed otherwise it would be an instant
 movement.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
The idea of actions is fairly simple to use and it is there to hide the
 user of the engine from a lot of hassle that happens behind the scene.
 It is meant to ensure thread safety and allow multiple threads working
 with the engine at once.
 The reasoning why we chose this design was for these exact reasons as we
 had to deal with the problem of interference from multiple concurrent threads.
 Furthermore it also is meant to reduce code redundancy as generic actions
 can be reused by other actions.
 The problem with this design is that it in a sense remakes what is already
 implemented in a programming language.
 As running procedural code is what programming languages are meant to do.
 However in return it provides a lot of utility and in the sense that it
 makes it possible to make tools for simplifying the process of making actions.
 As well it gives the ability to differentiate between different action
 types and even create new action type if one wishes to.
\end_layout

\begin_layout Subsection
Engine Extensions
\end_layout

\begin_layout Standard
Since most of the engine is very abstract in functionality, we have made
 three extensions, which makes it easy to implement a tile based environment
 and communicating with EIS.
\end_layout

\begin_layout Subsubsection
Tile Extension
\end_layout

\begin_layout Standard
This extension represents the world as a two-dimensional array of tiles
 using what we will call a tile map.
 
\family typewriter
\emph on
[Elaborate on tile, that entities can move]
\family default
\emph default
 We have implemented it so that the tile in the center has the position
 
\begin_inset Formula $(0,0)$
\end_inset

.
 This means that all positions are given relative to the origo tile at 
\begin_inset Formula $(0,0)$
\end_inset

.
 As a consequence of this, a tile map must have odd dimensions, as it would
 otherwise not have a center tile.
 If the user tries to access a tile that is out of bounds (for example the
 tile at position 
\begin_inset Formula $(0,n+1)$
\end_inset

 in a 
\begin_inset Formula $n\times n$
\end_inset

 tile map), a tile containing a special entity signaling that the tile is
 not part of the world is returned.
 This ensures that querying the tile map for a tile at any position will
 never fail and always return a valid value.
 As well as accessing tiles at arbitrary positions, the tile map can be
 queried with a position and a range 
\begin_inset Formula $r$
\end_inset

, in which case a two dimensional array of size 
\begin_inset Formula $(2r+1)\times(2r+1)$
\end_inset

 is returned, containing the tiles in that square.
 
\family typewriter
\emph on
[Figure?]
\end_layout

\begin_layout Standard
In the tile extension, we have provided several modules that can be equipped
 to agents to make them better suited for inhabiting a tile based environment.
 For example, the 
\emph on
movement blocking-
\emph default
 and 
\emph on
vision blocking
\emph default
 modules apply to all entities with a physical presence in the environment;
 given another entity, they specify whether the entity they are attached
 to blocks the aforementioned entity's movement or vision, respectively.
 The 
\emph on
speed
\emph default
 module defines how long it takes for the entity to move to an adjacent
 square.
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Vision?, move action, move event]
\end_layout

\begin_layout Subsubsection
EIS Extension
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Subsection
Model
\end_layout

\begin_layout Subsubsection
World
\end_layout

\begin_layout Standard
To be able to unambiguously reference an entity, they are assigned an 
\family typewriter
id
\family default
 (represented as a number) in the engine.
 This is relevant when, for example, a backend APL such as GOAL executes
 an action involving other entities than the agent it is controlling.
 In this case, the entity's position can be amiguous, since several agents
 may very well occupy the same spot in the world.
\end_layout

\begin_layout Standard
To hold references to all entities in the environment, the 
\family typewriter
XmasWorld
\family default
 class contains a set of mappings (a C# 
\family typewriter
Dictionary
\family default
) from 
\family typewriter
id
\family default
s to entities.
 Since all agents have a name, it also contains mappings from names to agents.
 
\end_layout

\begin_layout Standard
When an entity is added to the world, the variable holding the last used
 
\family typewriter
id
\family default
 is increased by one, and the entity is associated with this number.
 This ensures unambiguity, since no number can be used twice.
 However, it does impose a limit on the number of entities that can be added
 to the world.
 We have represented the 
\family typewriter
id
\family default
 as a 64 bit unsigned integer (C#
\family typewriter
 ulong
\family default
 type), so it supports adding more than 
\begin_inset Formula $1.8\times10^{19}$
\end_inset

 entities.
 In an environment that is meant to run indefinetely, and where entities
 are added and removed often (such as a server based website indexing tool),
 this limit may be a concern.
 
\end_layout

\begin_layout Standard
The process of assigning 
\family typewriter
id
\family default
s to entities is handled in the 
\family typewriter
AddEntity
\family default
 method, which takes as arguments the entity to be added and an 
\family typewriter
EntitySpawnInformation 
\family default
object, containing the desired position of the entity in the world, and
 any other relevant information, such as initial state.
 However, this only occurs after the user-implemented method 
\family typewriter
OnAddEntity
\family default
 is called with the entity and spawn information as arguments, and has returned
 success.
 This method is overridable by the designer, and can be used to ensure that
 entities are added properly to the custom world, or not at all.
 For example, if the world has the restriction that no two entitites can
 start in the same position, 
\family typewriter
OnAddEntity
\family default
 can be implemented so as to return failure when an the entity in question
 would be spawned in an occupied position.
 Alternatively, it may correct the error, for example by placing the entity
 in an adjacent, unoccupied square and return success.
 In any case, the 
\family typewriter
AddEntity
\family default
 method propagates the return value from 
\family typewriter
OnAddEntity
\family default
 to its caller when it returns.
\end_layout

\begin_layout Standard
The 
\family typewriter
RemoveEntity
\family default
 method dereferences the entity by removing itself and its 
\family typewriter
id
\family default
 from the previously mentioned set of mappings.
 Similarly to the 
\family typewriter
AddEntity
\family default
 method, it calls the user-supplied 
\family typewriter
OnRemoveEntity
\family default
 method, and returns its return value.
 
\family typewriter
\emph on
[entity.OnLeaveWorld?]
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[pseudo code for AddEntity, RemoveEntity?]
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[abstract methods in System Features?]
\end_layout

\begin_layout Subsubsection
Events and Triggers
\end_layout

\begin_layout Standard
This section will cover the inner workings of how events and triggers are
 connected, furthermore it will detail why we designed it as it is.
 We will also cover exact producer when an event is raised, to defuse any
 confusion their might be as to what happens inside the engine.
\end_layout

\begin_layout Paragraph*
Explanation
\end_layout

\begin_layout Standard
By themselves events are not particularly complicated since they are essentially
 just date structures that are transferred to all its listeners upon triggering.
 As such we shall do a close examination of how exactly the
\family typewriter
 EventManager 
\family default
works.
\end_layout

\begin_layout Standard
The 
\family typewriter
EventManager
\family default
 is tethered through the engine to all entities that are inside, whenever
 an entity has an event raised on it; it is copied to the event manager
 which also raises the event.
 The intent is to minimize the number of events needed to cover a single
 case.
 To be clear on how exactly this transpires we have drawn a sequence diagram.
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[SHOW Sequence diagram of an event being raised on an entity and then transferre
d to the event manager]
\end_layout

\begin_layout Standard
As shown on this sequence diagram, an action in this case a move action
 raises an 
\family typewriter
EntityMoved
\family default
 Event on a given entity, the entity then calls all triggers registered
 to it, where the trigger also contain the event being raised.
 After this the entity informs the 
\family typewriter
EventManager
\family default
 that an event has been raised on this, this causes the 
\family typewriter
EventManager
\family default
 to also call all its registered Triggers with the given Event.
 Once all relevant triggers have been informed of the Event being raised,
 the procedure is complete and the 
\family typewriter
EventManager
\family default
 returns to its dormant state.
\end_layout

\begin_layout Standard
In the case of events are not linkable to a specific entity such as an “Engine
 Close Event” the raise of the event to done purely on the 
\family typewriter
EventManager
\family default
 itself.
 The process is otherwise the exact same as above except that no particular
 entity is involved.
\end_layout

\begin_layout Paragraph*
Considerations
\end_layout

\begin_layout Standard
As there were many considerations that went through our design process we
 will take each component of this area and break down why exactly why we
 designed it as is.
\end_layout

\begin_layout Subparagraph*
Problems of C# events and why we chose to design our own events
\end_layout

\begin_layout Standard
The language which our engine is written in is C#, one of the fantastic
 things about C# is that events is built into the language, as such it may
 come as a surprise that we have chosen to re-implement events ourselves.
 However while the name be the same the intent between C# events and our
 events is so different that it is impossible to compare the two.
 The intent behind C# events is to keep maintenance on single objects, so
 that changes to a given object can affect its linked objects without having
 to be designed specifically to do so.
 This allows for great decoupled projects and is what makes object maintenance
 in C# quite easy.
 However our events are not meant for such low-level tasks instead they
 are meant to allow reactions to occur in responds to other actions.
 Furthermore C# actions are bound to a specific class, and can only be fired
 inside methods of an instantiation of the specific class.
 The events we have designed are meant to be raised by all types of class
 that wish to signal such an event has occurred.
\end_layout

\begin_layout Standard
To give an idea of what sort of problems that would arise from using C#
 events one need only look at how global events would have to be implemented.
 Since Events using C# are linked to a specific class, which would essentially
 mean that the EventManager class would need to be setup for every single
 event the engine is capable of running.
 What this basically has accomplished is to couple a single class into the
 entire workings of an engine, this makes for poor programming design in
 more than one way and greatly reduces productivity.
 It also makes the engine difficult to extend and modify at a later time
 since the design would be practically hardcoded into it.
\end_layout

\begin_layout Subparagraph*
Improvemens of events
\end_layout

\begin_layout Standard
As of now our events are currently not tied to being an Entity Event or
 environment Event like actions are, however this might have been a wrong
 move on our part.
 The problem is that the user of the engine might be unclear as to which
 is what, currently the difference lies in the name convention used for
 events.
 For instance an event such as “EntityMoved” it is clear that this is an
 event that can be tied to a specific entity.
 However for an event such as “AddedEntityToEngine” this might be confusion
 because the event is clearly speaking about a single entity but as the
 entity is only just added it would have been impossible for any trigger
 to be registered to it.
 If one was to make improvements to the event design this would be one change
 that was worth looking into.
\end_layout

\begin_layout Subparagraph*
Triggers
\end_layout

\begin_layout Standard
The trigger design came about as a necessity for providing a way for the
 user to easily design reactions to a given event.
 The trigger design is very minimalistic except for the fact that it has
 a condition.
 We designed it with the condition because we wanted it to be obvious how
 unwanted events should be handled.
 Furthermore it also helps to split up the code containing if the action
 should be executed away from the action itself allowing for more readable
 code.
 
\end_layout

\begin_layout Standard
Another way the triggers could have been designed would be if the user simply
 registered lambda functions(anonymous function), this would help reduce
 the amount of class a user should know and understand.
 However we preferred to encapsulate this into what we call the Trigger,
 since we wanted to have the ability to expand the capability of the trigger
 at a later time.
\end_layout

\begin_layout Standard
In short triggers are a simple design that gives the engine logic a lot
 of flexibility.
 
\end_layout

\begin_layout Paragraph*
Summary
\end_layout

\begin_layout Standard
Events and triggers might be a hassle to setup and design however what they
 return in value is tenfold to that, they provide the engine with much flexibili
ty.
 Without Events the engine would suffer greatly and all actions would be
 required to be bogged down with a lot of extra logic.
 This would not only remove the modularity of the engine but also make using
 engine more error-prone.
\end_layout

\begin_layout Subsubsection
Actions
\end_layout

\begin_layout Standard
As we already went through what actions can be used this section will keep
 that to a minimum and instead focus on our idea behind, and how we implemented
 them.
 It will furthermore cover the entire life span of an action object.
\end_layout

\begin_layout Paragraph*
Explanation
\end_layout

\begin_layout Standard
An action -- or 
\family typewriter
XmasAction,
\family default
 as it is called in our engine
\family typewriter
 
\family default
-- is a class which provides an API for performing state changes inside
 the engine, while also ensuring that only one action at a time is being
 executed.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImplementationActionQueuingExplanation.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ImplementationActionQueuingExplanation"

\end_inset

A sequence diagram describing the execution of an action.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ImplementationActionQueuingExplanation"

\end_inset

 it starts with the 
\family typewriter
XmasModel
\family default
 running an endless loop that tells the 
\family typewriter
ActionManager
\family default
 to execute all newly queued actions.
 The 
\family typewriter
ActionManager
\family default
 then takes all the actions from a thread safe list and places them in a
 local list.
 After this, each action is executed individually, putting the action that
 is being executed in a running state, this state will not change before
 the actions 
\family typewriter
Completed
\family default
 method is called.
 Once an action has been properly executed, it will be changed to a completed
 state and will be properly disposed of.
 When the last action has been executed by the 
\family typewriter
ActionManager
\family default
, the call to 
\family typewriter
ExecuteActions
\family default
 returns and 
\family typewriter
XmasModel
\family default
 will put the thread in a waiting state.
 The 
\family typewriter
XmasModel
\family default
 will remain in wait state until a new action has been placed on the queue;
 this is preventing it from busy waiting when no actions are to be executed.
\end_layout

\begin_layout Paragraph*
Considerations
\end_layout

\begin_layout Standard
The way that action completion is designed might seem tedious in that it
 has to call a special method 
\family typewriter
Completed
\family default
 on each action however it is quite necessary as the completion of the execute
 method call does not guarantee that a method is completed.
 
\end_layout

\begin_layout Standard
The reason why the completion of the method 
\family typewriter
Execute
\family default
 does not guarantee that Action has actually completed is that in cases
 of actions not being instantaneous the rule would not apply.
 To give an example of such action, take the action of moving from one place
 to another.
 In this case the move action would need to create a timer to give the idea
 that the move action had a speed.
 As we can’t halt other actions during this time it is paramount that the
 Execute method is released so that other actions can be executed during
 this period.
 
\end_layout

\begin_layout Standard
This is also how the move action is designed in our reference implementation,
 the algorithm is as follows
\end_layout

\begin_layout Enumerate
Move action put on queue 
\end_layout

\begin_layout Enumerate
Move action sets up a timer on a different thread and finishes its execution
\end_layout

\begin_layout Enumerate
The timer is fired after a given time, and places a new action on the queue
\end_layout

\begin_layout Enumerate
The new action performs the actual move, and calls the 
\family typewriter
Completed
\family default
 method of its parent Action (the 
\family typewriter
MoveAction
\family default
)
\end_layout

\begin_layout Standard
As one can see the problems in this design is the redundancy created by
 having to call a method on each execute, this might not seem like a problem
 however it is problematic in a few ways.
 First and foremost it adds complexity in usage of the engine, a person
 with no knowledge of using the engine would not have a way in realizing
 the correct way to make and use actions.
 Thus it creates a second problem there is no way to determine if an Action
 is correctly constructed during compile time, this means bugs will naturally
 accumulate during extended use, even if a user has experience and foreknowledge
 forgetting even for a single action can be crucial.
 This is because running actions use resources and if never completed the
 resources of the actions are never released.
 For instance let us assume the 
\family typewriter
MoveAction
\family default
 
\family typewriter
Completed
\family default
 method is never called, the result of this is that it is stored in the
 
\family typewriter
ActionManager
\family default
 as 
\family typewriter
Running
\family default
.
 Now let us assume that this move action is continuously being executed
 by hundreds if not thousands of agents.
 As each action is never released the memory stored for each action is never
 released and an unintentional memory leak is thus created.
\end_layout

\begin_layout Standard
Another way we could have chosen to implement the action completion process,
 is the usage of child action.
 Imagine if an action could generate new actions that were linked with it,
 thus the completion of an action would be tied to the fact that all its
 child actions had been executed and not the arbitrary call of a 
\family typewriter
Complete
\family default
 method.
 This could undoubtedly provide new problems to overcome and as such we
 have not fully followed this path, however given more time to study the
 consequences of this design would reveal whether or not this is a better
 design.
 
\end_layout

\begin_layout Paragraph*
Summary
\end_layout

\begin_layout Standard
A lot of the considerations when designing the action all comes down to
 the reliance on user to clean up the Action, which is generally not good
 from a design perspective; it is always preferable that used data is cleaned
 up automatically when it is out of scope.
 However it is not all bad as this design does guarantee a flexible usage
 of the actions; it provides more control to the user which might give the
 user abilities to do certain things which would otherwise be denied within
 the engine.
 This is also why this design method was chosen as our philosophy in the
 engine design was to minimize limitations as much as possible while still
 providing the features we thought necessary to fulfill the engines goal.
\end_layout

\begin_layout Section
\start_of_appendix
iiLang (and xml serialization/deserialization?)
\end_layout

\begin_layout Section
Network Streaming
\end_layout

\end_body
\end_document
