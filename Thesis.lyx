#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{alltt}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 4
\tocdepth 4
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
There are many complications when developing multi agent systems, our goal
 with this project was to lessen one of these by designing an engine with
 the specific purpose to develop multi agent environments.
 What these environments can be is left to the developer, however almost
 everything in the engine is modular and interchangeable, ensuring that
 all types of multi agent environments are possible.
 
\end_layout

\begin_layout Standard
What the types of projects can be is manyfold but here are some possible
 examples:
\end_layout

\begin_layout Paragraph*
Agent comparison software 
\end_layout

\begin_layout Standard
There are many different languages in which it is possible to write agent
 programs, some are specifically designed for it others are powerful enough
 to accommodate the possibility of agent programming.
 Our engine is designed with support for multiple languages at once which
 makes this engine a perfect candidate for designing a comparator program.
 
\end_layout

\begin_layout Standard
For instance, if two groups wanted to test their agent programs against
 each other, this engine would make it possible for them to easily design
 a world in which this test could occur.
\end_layout

\begin_layout Paragraph*
Agent testing/Simulation software
\end_layout

\begin_layout Standard
Testing agent software can be complicated.
 Being able to rapidly create an environment and visualize it can be important
 to the project, as it ensure basic mistakes are ironed out before larger
 scale implementation.
 
\end_layout

\begin_layout Paragraph*
Agent teaching tools
\end_layout

\begin_layout Standard
Teaching agent languages can be tough without proper exercises; however,
 the time spent on designing these exercises can prove too exhausting for
 the teacher to develop.
 In this case the teacher can rapidly design the world he had in mind for
 his exercise instead of designing every integral part of the multi agent
 system himself.
 This is because our engine provides all the basic features of a multi agent
 system, so that the time can be spent more productively on designing how
 a given exercise should play out, showcasing the problem the students are
 supposed to deal with.
\end_layout

\begin_layout Paragraph*
Computer games
\end_layout

\begin_layout Standard
In theory most computer games are just multi agent programs where one of
 the agents is controlled by the player.
 Our engine should make it fairly easy for setting up a framework for creating
 rules inside a given world and ensure that the agents of the world follow
 said rules.
 
\family typewriter
\emph on
[Expand]
\end_layout

\begin_layout Section
Theory
\end_layout

\begin_layout Subsection
Multi-Agent Systems
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Missing]
\end_layout

\begin_layout Subsection
Model View Controller
\end_layout

\begin_layout Standard
To ensure that code is correctly decoupled from one another, strict design
 patterns are necessary, as these allow developing complex projects without
 losing the sight of the entire project.
 If no pattern is followed, code can easily become so entangled that later
 development might prove impossible.
 This section will cover all the rules and ideas behind the MVC (Model-View-Cont
roller) design pattern.
\end_layout

\begin_layout Standard
The MVC pattern principle is that programs that can be interacted with by
 a user can be split into three different components.
 These components are as follows:
\end_layout

\begin_layout Itemize
Model -- Core of the program
\end_layout

\begin_layout Itemize
View -- Visualization of the program
\end_layout

\begin_layout Itemize
Controller -- Manager of state changes to the core of the program
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename MVC.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MVCBasic"

\end_inset

This image shows how the three components are connected to each other; the
 full arrows indicate that a component has complete knowledge of the component
 it is pointing to.
 A dashed arrow indicates that the component the dashed arrow is pointing
 to is listening to the component the arrow is originating from.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Model
\end_layout

\begin_layout Standard
The model is the core of the program.
 It is why the program functions as it does, it contains all information
 of the data, and it is here all business logic is located.
 The model should have no knowledge of either the view or the controller;
 by not knowing either the program is ensured to not be tainted by their
 influence.
\end_layout

\begin_layout Standard
While it may not know of the view or the controller, it is paramount that
 the model is built to optimally transfer information concerning its current
 state.
 That means that providing a way for other components to listen on the model
 is very welcome
\emph on
.
 
\emph default
This gives the model a way to publish its state when it has been altered
\emph on
.

\emph default
 What this does for the model is that in the case that model state has been
 altered, it will have a way to provide the information of the state.
 
\end_layout

\begin_layout Standard
If such features are not built into the model then it would require the
 component changing the state to inform of the state changes, in case of
 a MVC design.
 The component changing state is the controller and such the controller
 would both have the duty of changing the state and maintaining the view.
 This is generally the case of a badly designed model and can be completely
 avoided if the model simply has the ability to inform its listeners of
 any changes.
\end_layout

\begin_layout Subsubsection
View
\end_layout

\begin_layout Standard
The view is a way to visualize what is currently occurring inside model
 by visualizing it to the user.
 A view may take many shapes depending on the model.
 If, for instance, the model is a program crunching data on a server, then
 the view could take the form of a logging console.
 Or if the model was a computer game then the view would be the graphic
 representation of the game.
 Additionally, a model can have severl views, each displaying information
 in a different manner.
 For example, the computer game mentioned above could also feature a view
 printing debugging information to a console while the game was running.
 Generally, a view should only have knowledge of the model and not the controlle
r.
 The idea is that if the model data is complete then interaction with the
 controller should not be necessary.
\end_layout

\begin_layout Standard
When designing a view there are some common pitfalls that happen easily
 if one is not careful of the design.
 First off, the view is what it is named; a view.
 This means that it should never do any state changes to the model.
 If getting hold of data means that the model must change its state to accommoda
te this, then the model is poorly made and should be changed.
 However, a view is allowed to change its own state without involving either
 the controller or model.
 To fully understand what is meant by this, consider the following example:
\end_layout

\begin_layout Standard
Assume you have a menu bar as depicted in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:menubar"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename MenuBar.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:menubar"

\end_inset

A standard menu bar.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To open a menu, the user need to drag the mouse and click on one menu he
 or she wishes to open.
 Many would see this as a task of the controller.
 This is not the case, however, since the changes done are only performed
 on the view's own state and not the model of the program.
\end_layout

\begin_layout Subsubsection
Controller
\end_layout

\begin_layout Standard
The controller is the link between the model and the user.
 By convention, all changes the user wishes to perform on the model should
 be done through the controller.
 Like the view, it can take many shapes, like an object that transforms
 input from the mouse into changes to the model, or an object controlling
 how a network data stream effects on the model.
 
\end_layout

\begin_layout Standard
In a well-designed program the controller should never have to interact
 with the view.
 However, this can be practically impossible on larger projects unless they
 are carefully planned, and as such the controller by convention is allowed
 to know of both the view and the model.
\end_layout

\begin_layout Standard
A common mistake when designing the controller is to mistake the unit which
 the controller gets input from as the actual controller.
 In many cases, the keyboard is the device from which input is transformed
 into state changes to the model.
 However, that does not mean that the controller should be the only unit
 interacting with the keyboard.
 Going back to the example used to understand the view, the reason why the
 controller should not deal with opening a menu bar on the view is because
 the controller is not responsible of the state of the view.
 The controller is only responsible for the state of the model; the only
 case in which it is allowed for the controller to interfere with the view
 is in the case that the model was unsuccessful in properly informing about
 its state change caused by the controller.
 In this case it is okay for the controller to call the view and ask it
 to adjust itself.
 
\end_layout

\begin_layout Standard
The reasoning for why the controller is normally mistaken to be responsible
 for handling changes to the state of the view is because it is mistakenly
 thought of as a controller for the entire program and not the model, a
 view may contain its own controller which should not be mistaken from the
 other controller.
 To fully understand this, imagine that the view in itself also contains
 a MVC inside itself (see fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MVCeption"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename MVCeption.png
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MVCeption"

\end_inset

A view with a MVC inside of it.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The model of a view (such as a menu bar) would contain data about the names
 of the menus and it would be responsible for ordering and accessing information
 as to what each menu contains.
 Its view would be that of a drawing board responsible for properly drawing
 the menu bars.
 Luckily, most views are simple, so one does not need to make an entire
 MVC design, but for graphical user interface used in most operating system
 it is very important to understand that a view can be an entire MVC setup
 in itself.
 This is why most operating system comes with libraries to easily design
 GUI.
\end_layout

\begin_layout Subsection
Factory Design Pattern
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Missing]
\end_layout

\begin_layout Subsection
Test Driven Development
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Missing]
\end_layout

\begin_layout Section
Reference Implementation
\end_layout

\begin_layout Standard
To showcase and test our engine, we have used it to create a simple environment
 with a tile based world.
 In this world, agents are tasked with finding packages in a maze and dropping
 them at a tile containing a 
\family typewriter
dropzone
\family default
 (see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:maze-scrot"

\end_inset

).
 Agents are controlled by separate GOAL instances with an EIS environment,
 which communicates with the XMAS engine via XML messages passed over sockets.
 The agent programs catalogue the tiles they can see and uses A* search
 to find paths to packages and the dropzone.
 The actions available to an agent are listed below.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename TileWorldColoredScrot.png
	width 20text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An initial configuration of the package grabber scenario.
 
\family typewriter
D
\family default
 (red) marks the dropzone, 
\family typewriter
X
\family default
s (green) are packages, 
\family typewriter
A
\family default
s (black) are agents and 
\family typewriter
W
\family default
s (grey) are walls
\begin_inset CommandInset label
LatexCommand label
name "fig:maze-scrot"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
move(
\emph on
Direction
\emph default
)
\family default
 moves the agent one tile in the specified 
\family typewriter
\emph on
Direction
\family default
\emph default
.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
grab
\family default
 removes the package in the same tile as the agent (if any) from the world,
 and marks the agent as carrying a package.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
drop
\family default
 adds a package to the world in the same tile as the agent (if it is carrying
 a package) and marks the agent as not carrying a package.
\end_layout

\begin_layout Standard
Additionally, we plan to implement a messaging action, allowing the agents
 to communicate with each other.
 This is particularly necessary when using GOAL, as the GOAL instances have
 no knowledge of each other and thus cannot use the messaging system built
 into GOAL.
\end_layout

\begin_layout Section
System Features
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
The goal of the engine is to allow for simulation of a world where agents
 within are allowed to act.
 As such, it is important that it can accurately model a state-machine.
 To model a state-machine, one must have the ability to save a state and
 perform actions to change the current state.
 A complete UML Domain model diagram is provided in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Domain-Model-UML"

\end_inset

.
\end_layout

\begin_layout Subsubsection
State
\end_layout

\begin_layout Standard
In our domain model, we have state stored in three object types:
\end_layout

\begin_layout Itemize
World
\end_layout

\begin_layout Itemize
Entities
\end_layout

\begin_layout Itemize
Modules
\end_layout

\begin_layout Paragraph*
World
\end_layout

\begin_layout Standard
The world is the place all entities are meant to inhabit as either agents
 of the world or simply objects for the entities to interact with.
 The world is not defined by the engine.
 As shown in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:DomainModelDiagramXMAS"

\end_inset

, it is an abstract class, meaning it is the developer using our engine
 that defines the world.
 As such the world can be any type of world needed, it could be a 3-d world,
 a 2-d world, a world based on tiles or hexagons or simply be nodes with
 an undefined number of edges connecting each other.
\end_layout

\begin_layout Paragraph*
Entities
\end_layout

\begin_layout Standard
The world is empty without anything inside it, as such we have the entities
 which are meant to model the objects one would have the world contain.
 For example in our reference implementation using our engine, we have a
 world with packages scattered about a maze.
 It is then the task of the agents to collect these packages; the entities
 here are not only the walls of the maze and the packages, but also the
 agents since they inhabit the world as well.
 The agents are different from entities in that they all have a name.
 This name is unique and is meant to be a way of distinguishing the agents
 from one another.
 
\end_layout

\begin_layout Paragraph*
Modules
\end_layout

\begin_layout Standard
The modules can be viewed as the constraints and as the abilities of all
 entities.
 For instance if you wanted to constrain entities from moving into each
 other than you would create a Movement blocking module, this module would
 then contain information on whether or not a given entities is allowed
 to pass through it.
 
\family typewriter
\emph on
[Rewrite?]
\end_layout

\begin_layout Subsubsection
Actions
\end_layout

\begin_layout Standard
A world is static and unexciting if one is not allowed to perform any changes
 to it, for this we have what we have chosen to name actions.
 There are two different types of actions: environment actions entity actions.
 The core difference between them is that entity actions are meant as actions
 performed by a single entity, such as moving the entity or having the entity
 pick up another object.
 Environment actions are actions that affect the entire world.
 In our domain model, we have chosen to add two actions that are built into
 the engine, the first is an entity action that gets all the percepts for
 a given entity called 
\family typewriter
GetallPerceptsAction
\family default
 and the other is an environment action that can shut down the engine called
 
\family typewriter
CloseEngineAction
\family default
.
 
\end_layout

\begin_layout Subsubsection
Events and Triggers
\end_layout

\begin_layout Standard
The engine relies heavily upon events, this means that all actions performed
 within the engine is meant to trigger events in responds.
 This can be used to either activate new actions within the engine, or be
 meant to transfer data to the views listening.
 
\end_layout

\begin_layout Standard
In order to listen to the events, a trigger need to be created with all
 the events it listens to registered to it.
 Furthermore, a trigger needs a condition and an action.
 The condition is a predicate that determines whether the trigger is fired,
 and the action is the function that is excuted when the trigger is fired.
\end_layout

\begin_layout Subsection
Virtual World
\end_layout

\begin_layout Standard
The object used to keep track of all entities in the environment is called
 the 
\emph on
world
\emph default
.
 This object is also used to model the structure of the environment; eg.
 whether it is tile based, graph based or something else entirely.
 The only restriction imposed on the structure of the environment is that
 all entities have an associated 
\emph on
position
\emph default
 in it, fitting the data structure describing the environment.
 This is a pretty loose requirement, considering that it can effectively
 be ignored 
\family typewriter
\emph on
[could any meaningful environment be constructed where position doesn't
 matter?]
\end_layout

\begin_layout Standard
In a tile based environment, for example, the world could consist of a two
 dimensional array containing lists of entities, with each field representing
 a tile, and positions represented as 
\begin_inset Formula $(x,y)$
\end_inset

 coordinates.
 In a graph based environment, the world would contain some structural represent
ation of a graph, and the positions could be references to nodes, or representat
ions of the graph as seen from different nodes.
 
\family typewriter
\emph on
[More detailed usage examples?, Tile Extension]
\end_layout

\begin_layout Subsubsection
Entities, Agents and Entity Modules
\begin_inset CommandInset label
LatexCommand label
name "sub:SysFeatEntities"

\end_inset


\end_layout

\begin_layout Standard
Entities are the objects inhabiting the world.
 They are very basic objects, equipped with no definitions of how they are
 represented in the world or how they can be interacted with, save for allowing
 other objects to subscribe to events fired by the entity.
 All this is instead handled by 
\emph on
entity modules
\emph default
, which each entity contains a set of.
 These modules can be queried and called by other objects.
 An entity could, for example, have a 
\emph on
speed
\emph default
 module -- as is the case in the tile extension -- specifying how long it
 takes to move from one position to another.
\end_layout

\begin_layout Standard
When modules are asked to identify themselves, they do so by means of a
 
\emph on
module type
\emph default
.
 Two modules are identical -- from the viewpoint of an entity -- if their
 module types are identical.
 As such, only one occurrence of any module type can exist in a set of modules.
 and a module of type 
\begin_inset Formula $t$
\end_inset

 on an entity 
\begin_inset Formula $e$
\end_inset

 can unambiguously be reffered to as 
\begin_inset Formula $e.M_{t}$
\end_inset

, where 
\begin_inset Formula $M$
\end_inset

 is 
\begin_inset Formula $e$
\end_inset

's module set.
 
\end_layout

\begin_layout Standard
It is perfectly legal (and sometimes recommended) for a module to identify
 itself by another type.
 This means that if a module 
\begin_inset Formula $m_{1}$
\end_inset

 of type 
\begin_inset Formula $t$
\end_inset

 is registered to an entity 
\begin_inset Formula $e$
\end_inset

, which already has a module 
\begin_inset Formula $m_{0}$
\end_inset

 of type 
\begin_inset Formula $t$
\end_inset

 attached (such that 
\begin_inset Formula $e.M_{t}=m_{0}$
\end_inset

), 
\begin_inset Formula $m_{1}$
\end_inset

 replaces 
\begin_inset Formula $m_{0}$
\end_inset

 in the set, and 
\begin_inset Formula $e.M_{t}=m_{1}$
\end_inset

.
 Additionally, when the new module is registered to the entity, it checks
 to see if any modules with the same type is already attached.
 If that is the case, it stores a reference to the original, and re-attaches
 it when it is itself detached.
 This allows for using filter modules, which can use the functionality of
 the module they have replaced to produce a modified output.
\end_layout

\begin_layout Standard
As an example, consider an entity 
\emph on
e
\emph default
 with a 
\emph on
speed
\emph default
 type module 
\begin_inset Formula $s_{0}$
\end_inset

.
 Assume that 
\begin_inset Formula $s_{0}$
\end_inset

 has a method 
\emph on
Speed
\emph default
, such that 
\begin_inset Formula $s_{0}.Speed$
\end_inset

 returns the speed of 
\begin_inset Formula $e$
\end_inset

.
 If it is for some reason desired to change the movement speed of entity
 
\emph on
e
\emph default
 by 50%, it is recommended practice to register a new module 
\begin_inset Formula $s_{1}$
\end_inset

 to the entity, which identifies itself as a 
\emph on
speed
\emph default
 type module, and likewise has a method 
\emph on
Speed
\emph default
.
 As 
\begin_inset Formula $s_{1}$
\end_inset

 is registered to the 
\begin_inset Formula $e$
\end_inset

, it stores a reference to 
\begin_inset Formula $s_{0}$
\end_inset

, and replaces it so that 
\begin_inset Formula $e.M_{speed}=s_{1}$
\end_inset

.
 Now 
\begin_inset Formula $s_{1}$
\end_inset

's 
\emph on
Speed
\emph default
 method can be defined such that it returns half the value 
\begin_inset Formula $s_{0}$
\end_inset

 would, so that 
\begin_inset Formula $e.M_{speed}.Speed=s_{1}.Speed=\frac{s_{0.Speed}}{2}$
\end_inset

.
 If at some point this effect is no longer desired, 
\begin_inset Formula $s_{1}$
\end_inset

 can be deregistered from 
\begin_inset Formula $e$
\end_inset

, which causes 
\begin_inset Formula $s_{0}$
\end_inset

 to be reattached and 
\begin_inset Formula $e.M_{speed}=s_{0}$
\end_inset

 once again.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ModulesChainingExample.png
	lyxscale 20
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A 
\emph on
speed
\emph default
 module 
\begin_inset Formula $s_{1}$
\end_inset

 has replaced another (
\begin_inset Formula $s_{0}$
\end_inset

) of the same type on entity 
\emph on
e
\emph default
.

\emph on
 
\emph default
Some object requests the speed of entity 
\begin_inset Formula $e$
\end_inset

 by querying its 
\emph on
speed
\emph default
 module 
\begin_inset Formula $s_{1}$
\end_inset

.
 
\begin_inset Formula $s_{1}$
\end_inset

 then queries the 
\emph on
speed
\emph default
 module it replaced, and returns half its value.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that this 
\begin_inset Quotes eld
\end_inset

chaining
\begin_inset Quotes erd
\end_inset

 of modules can be applied indefinetely, allowing several modules to affect
 a single property of the entity.
 However, the module methods are called as a stack, which means that the
 method of the module inserted last is the first to be called.
 This imposes somewhat of a limit, and may not work as desired in all cases.
 Consider a stack of 
\begin_inset Formula $n$
\end_inset

 modules, where module 
\begin_inset Formula $m_{1}$
\end_inset

 has been pushed first, followed by 
\begin_inset Formula $m_{2}$
\end_inset

 and so on, so that 
\begin_inset Formula $m_{n}$
\end_inset

 is at the top of the stack.
 Then a module 
\begin_inset Formula $m_{i}$
\end_inset

 can not directly alter the way modules 
\begin_inset Formula $m_{i+1}\dots m_{n}$
\end_inset

 changes it output.
 This may or may not be desirable, depending on the situation.
 It is not possible, for example, to apply an effect causing an agent's
 speed to be set to 
\begin_inset Formula $x$
\end_inset

, no matter what happens, using this method.
\end_layout

\begin_layout Standard
Another issue the designer should be aware of is that it is possible to
 create a module 
\begin_inset Formula $m_{1}$
\end_inset

 of type 
\begin_inset Formula $t$
\end_inset

, intented to replace another module 
\begin_inset Formula $m_{0}$
\end_inset

 (as in the above example), and not implementing the same public methods
 in 
\begin_inset Formula $m_{1}$
\end_inset

 as in 
\begin_inset Formula $m_{0}$
\end_inset

.
 Doing this will cause a runtime exception.
\end_layout

\begin_layout Standard
An 
\emph on
agent
\emph default
 is a special entity which have a unique name and can collect percepts.
 When an agent is asked to return all of its percepts, it queries each module
 for any available percepts, and returns those as a collection.
 
\family typewriter
\emph on
[move this paragraph up (and rewrite?)]
\end_layout

\begin_layout Subsection
Events and Triggers
\end_layout

\begin_layout Standard
In this part the concepts and ideas of both events and triggers will be
 explained.
 We will go through their intention and how to use them with the engine.
 Furthermore, a couple of examples will be provided to give the general
 idea of what they can be used for.
 
\end_layout

\begin_layout Subsubsection
Concept
\end_layout

\begin_layout Standard
In the natural world, all actions have a reaction, these reactions could
 be thought of as events meant to trigger when such actions are performed.
 Thus an engine for modeling a virtual environment must provide as many
 features as those of the real world environment.
\end_layout

\begin_layout Paragraph*
Events
\end_layout

\begin_layout Standard
To be clear, an event in the context of this engine is the occurrence of
 something, for instance an event could be that “an Agent has moved”, or
 “an Agent has picked up an item”.
 Furthermore, an event also has the duty of providing necessary information
 for the listener, giving the listener a correct idea of the meaning behind
 an event.
 In the case of the event which signified the movement of an agent, it is
 necessary to provide the listener 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Listeners refer to the object which is listening to the occurrence of an
 event, with the intent of reacting to it
\end_layout

\end_inset

 with information of which direction the agent moved, where its starting
 position is and how far it has moved.
 Since a listener might be operating in a different thread, the listener
 is completely dependent on this information, as it might no longer be retrievab
le at the time the event is being analyzed.
 For instance, if an agent moved and then was killed and removed from the
 world, its position would no longer be stored in the world.
 As such, the listener would have no way to determine where the move had
 ended if this information was not provided in the event.
\end_layout

\begin_layout Paragraph*
Triggers
\end_layout

\begin_layout Standard
Triggers in our engine are the means to which listeners gain access to events.
 A trigger in our engine is the combination of three different parts.
\end_layout

\begin_layout Itemize
Events
\end_layout

\begin_layout Itemize
Condition
\end_layout

\begin_layout Itemize
Action
\end_layout

\begin_layout Description
The
\begin_inset space ~
\end_inset

events are what the trigger is listening for.
 These can be any type of event, and a trigger can be registered to any
 number of events.
 But only one event is required to “trigger” a Trigger.
 For instance, if a Trigger is listening on both the events “10 seconds
 passed” and “Agent has moved”, then the Trigger will be “triggered” when
 either of these events occur.
 However it will be triggered each and every time such event has occurred
 and is not limited to just one occurrence.
\end_layout

\begin_layout Description
The
\begin_inset space ~
\end_inset

Condition is a built in predicate for the trigger to check if it is willing
 to respond to the event.
 If the condition is satisfied, the trigger’s action is fired.
 A condition should only be used in cases that is not covered by another
 event.
 For instance, say you have the event “An agent has moved”.
 Let us call the agent that moved 
\begin_inset Formula $a_{m}$
\end_inset

 and the agent whose movement you are interested in 
\begin_inset Formula $a_{i}$
\end_inset

.
 The condition on the trigger would then be: 
\begin_inset Formula 
\[
\textrm{\textbf{is }}a_{m}=a_{i}\textbf{ ?}
\]

\end_inset


\begin_inset Newline newline
\end_inset

As we can see the condition narrows the range of events that are responded
 to at the cost of added calculations.
 In this case it would be much better to subscribe to the event “Agent 
\begin_inset Formula $a_{i}$
\end_inset

 has moved”.
 This is purely an example as events should of course not be tied to specific
 objects.
 
\family typewriter
\emph on
[Make better example, explain why it is not feasible tie events to specific
 objects]
\end_layout

\begin_layout Description
The
\begin_inset space ~
\end_inset

Action of a trigger is the part that performs the work, it is a method which
 is executed once an event has been raised and the condition is satisfied.
 For instance if a trigger is meant to write a message when a specific event
 has occurred, then this is where the action of writing such a message should
 be placed.
\end_layout

\begin_layout Subsubsection
Entities and 
\family typewriter
EventManager
\end_layout

\begin_layout Standard
For triggers to become part of the engine it is required that the trigger
 is registered to the engine, however it is of crucial importance what one
 registers the trigger to.
 A trigger can be registered to either a specific entity or the 
\family typewriter
EventManager
\family default
.
 A Trigger registered to the 
\family typewriter
EventManager
\family default
 will be triggered each time an 
\family typewriter
Event
\family default
 that it is listening to is fired.
 However a 
\family typewriter
Trigger
\family default
 registered to a specific entity will only be informed of events raised
 on the specific entity instead of when the event is raised for every single
 entity.
 
\end_layout

\begin_layout Standard
An example of this would be: assume you have a Trigger 
\family typewriter

\begin_inset Formula $\mathtt{T_{1}}$
\end_inset


\family default
 with the event “An agent has moved”, and 
\family typewriter

\begin_inset Formula $\mathtt{T_{1}}$
\end_inset


\family default
 is registered to Agent 
\family typewriter
A
\family default
.
 Additionally, you have a Trigger 
\family typewriter

\begin_inset Formula $\mathtt{T_{2}}$
\end_inset


\family default
 with same event as 
\family typewriter

\begin_inset Formula $\mathtt{T_{1}}$
\end_inset

,
\family default
 but this trigger is registered to the EventManager.
 To give a complete picture, also assume there is an Agent 
\family typewriter
B
\family default
 which has no Triggers registered to it.
\end_layout

\begin_layout Standard
This provides us with two scenarios:
\end_layout

\begin_layout Description
Agent
\begin_inset space ~
\end_inset


\family typewriter
A
\family default

\begin_inset space ~
\end_inset

has
\begin_inset space ~
\end_inset

moved: In this case, both 
\family typewriter

\begin_inset Formula $\mathtt{T_{1}}$
\end_inset


\family default
 and 
\family typewriter

\begin_inset Formula $\mathtt{T_{2}}$
\end_inset


\family default
 is triggered, since 
\family typewriter

\begin_inset Formula $\mathtt{T_{1}}$
\end_inset


\family default
 listens on Agent 
\family typewriter
A
\family default
 and 
\family typewriter

\begin_inset Formula $\mathtt{T_{2}}$
\end_inset


\family default
 listens on any
\family typewriter
 
\family default
agent moving.
\end_layout

\begin_layout Description
Agent
\begin_inset space ~
\end_inset


\family typewriter
B
\family default

\begin_inset space ~
\end_inset

has
\begin_inset space ~
\end_inset

moved: In this case, only 
\begin_inset Formula $\mathtt{T_{2}}$
\end_inset

 is triggered, for the reasons stated above.
\end_layout

\begin_layout Subsubsection
Example of making and using an 
\family typewriter
Event
\end_layout

\begin_layout Standard
Let’s assume one was to make an event which was fired each time an agent
 had moved, let us name this Event: 
\family typewriter
AgentMoved
\family default
.
\end_layout

\begin_layout Standard
First, make a class extending the 
\family typewriter
XmasEvent
\family default
 class as shown below:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename XmasEventCreationStepOne.png

\end_inset


\end_layout

\begin_layout Standard
Then, add all the necessary data fields on the newly created event class.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename XmasEventCreationStepTwo.png

\end_inset


\end_layout

\begin_layout Standard
To utilize the newly created event, it must be raised when appropriate.
 In this case, the appropriate place would be to raise it during a move
 action.
\end_layout

\begin_layout Standard
In this action, after the movement of the agent had been performed, the
 method 
\family typewriter
RaiseEvent
\family default
 would need to be called on the entity that is being moved.
\end_layout

\begin_layout Subsubsection*
Summary
\end_layout

\begin_layout Standard
Events are what provides the engine flexibility and allows making reactions
 to others actions.
 Events are designed for ease of use and are meant to be used as much as
 possible.
 Triggers are used as a way to interface with events and they are the only
 way to connect an object to the event it wishes to listen to.
\end_layout

\begin_layout Subsection
Actions
\end_layout

\begin_layout Standard

\family typewriter
XmasAction
\family default
s in the UML Domain model diagram in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Domain-Model-UML"

\end_inset

 refers to the object type that performs actions inside the engine.
 The reasoning behind these actions being its own class is to ensure only
 one action at a time is being performed.
 This is because there are many separate threads operating on the model
 code at once and as such, there must be a way to active only one action
 at a time.
\end_layout

\begin_layout Standard
For the task of executing the actions we have the 
\family typewriter
ActionManager
\family default
.
 Its job is to take in one action at a time and place them in a queue (see
 fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ActionQueuing"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ActionQueuing.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ActionQueuing"

\end_inset

Sequence diagram illustrating how a 
\family typewriter
MoveEntityAction
\family default
 is processed.
 The idea is that a controller, such as keyboard input or an agent language,
 queues an action such as moving an entity on the action manager.
 The action manager will then execute the action as soon as it is ready.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Action Types
\end_layout

\begin_layout Standard
The engine is equipped with two different action types.
 One of them is the 
\family typewriter
EnvironmentAction
\family default
, which are actions that perform changes on the entire environment.
 Examples of such actions are closing this engine or adding/removing entities
 from the world.
\end_layout

\begin_layout Standard
The other action type is the 
\family typewriter
EntityAction
\family default
.
 This action type is meant as an action that a single entity performs; ideally
 the actions should be as atomic as possible.
 In our reference implementation we have given some ideas how these actions
 work, such as 
\family typewriter
grab
\family default
, which is an action that grabs a package from the tile the executing agent
 is standing on.
\end_layout

\begin_layout Subsubsection
Example -- Move Entity Action
\end_layout

\begin_layout Standard
Here we will show how an entity action is constructed by inheriting the
 
\family typewriter
EntityAction
\family default
 class.
 As shown in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MoveEntityActionExample"

\end_inset

, we have created a 
\family typewriter
MoveEntityAction
\family default
 class with one field containing the direction of the move.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename MoveEntityActionExample.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:MoveEntityActionExample"

\end_inset

 Illustrating the inheritance of the newly created 
\family typewriter
EntityAction
\family default
 
\begin_inset Quotes eld
\end_inset

MoveEntityAction
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To have the action actually perform something, it is required that an abstract
 method 
\family typewriter
Execute
\family default
 is implemented.
 This execute method is the method that is executed by the action manager.
 The implementation of the execute action could then look something like
 the following pseudo code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{alltt}
\end_layout

\begin_layout Plain Layout


\backslash
textit{method} Execute 
\backslash
textit{returns} nothing 
\end_layout

\begin_layout Plain Layout

    NewPosition = GetPositionOf(World, This.getSource()) + Direction 
\end_layout

\begin_layout Plain Layout

    Wait(MOVE_TIME) 
\end_layout

\begin_layout Plain Layout

    SetPositionOf(World,This.getSource(), NewPosition) 
\end_layout

\begin_layout Plain Layout


\backslash
textit{EndMethod}
\end_layout

\begin_layout Plain Layout


\backslash
end{alltt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As one can see, the idea is that you find the position of the source of
 the 
\family typewriter
EntityAction
\family default
 and use that to generate the new position, which is its old position incremente
d by its direction vector.
 The wait is there to give the move a speed, as it would otherwise be an
 instant movement.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
Using actions is fairly simple and serves to shield the user from the tedious
 and error prone workings that takes place behind the scenes.
 It is meant to ensure thread safety and allow multiple threads working
 with the engine at once.
 These were the exact reasons we chose this design, as we ourselves had
 to deal with the problem of interference from multiple concurrent threads.
 Furthermore, it will also reduce code redundancy as generic actions can
 be reused by other actions.
 The problem with this design is that it in a sense remakes what is already
 implemented in a programming language.
 After all, running procedural code is what programming languages are meant
 to do.
 However, in return it provides a lot of utility and makes it possible to
 make tools for simplifying the process of making actions.
 It also gives the ability to differentiate between different action types
 and even create new action types if one wishes so.
\end_layout

\begin_layout Subsection
Converting Actions and Percepts
\end_layout

\begin_layout Standard
Both actions and percepts are very abstract objects, and the XMAS engine
 can not how they are represented in different APLs.
 This means that the system designer needs a way to translate actions from
 foreign types into 
\family typewriter
XmasAction
\family default
s, and 
\family typewriter
XmasPercept
\family default
s into percepts of foreign types.
 We have provided the base necessities for implementing this functionality
 with 
\emph on
converters
\emph default
.
 A converter is, as the name implies, a class that takes objects of a foreign
 type and map them to internal types or vice versa.
 
\family typewriter
\emph on
[Expand]
\end_layout

\begin_layout Subsection
Agent Controllers
\end_layout

\begin_layout Standard
The purpose of the agent controllers is to be able to control agents in
 the engine from outside.
 This section will cover our design of an agent controller.
 To get an overview of the classes used for the 
\family typewriter
AgentController
\family default
, look at fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AgentControllerDomainModel"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename AgentControllerDomainUML.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Domain model for Agent Controller
\begin_inset CommandInset label
LatexCommand label
name "fig:AgentControllerDomainModel"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Concept
\end_layout

\begin_layout Standard
The engine is designed to support the ability to be adapted for all APL
\begin_inset Foot
status open

\begin_layout Plain Layout
Agent Programming Language
\end_layout

\end_inset

 types, this means that the engine itself does not support all APLs but
 instead provides a framework for quickly designing interfaces between the
 engine and any APL.
 There are two classes that one must use in order to properly design the
 interface:
\end_layout

\begin_layout Description
The
\begin_inset space ~
\end_inset


\family typewriter
AgentManager
\family default
 has the duty of speaking directly with the agent language it attempts to
 interface with.
 Its job is to spawn an 
\family typewriter
AgentController
\family default
 for each agent the AP wishes to take control of.
 The 
\family typewriter
AgentManager
\family default
 is in that sense much akin to an Abstract Factory, which according to the
 design pattern requires that an abstract class has a method generating
 a certain type of what object but not exactly which object
\family typewriter
\emph on
 [rewrite sentence]
\family default
\emph default
.
 The idea is of course that if you have a 
\family typewriter
GoalAgentManager
\family default
 then the controller it constructs would be 
\family typewriter
GoalAgentController
\family default
.
 By making it an abstract method, we ensure at compile time that the engine
 framework is properly used which is very good for the user.
 
\family typewriter
\emph on
[Explain]
\end_layout

\begin_layout Description
The
\begin_inset space ~
\end_inset


\family typewriter
AgentController
\family default
 is the link between a single agent and the AP 
\begin_inset Foot
status open

\begin_layout Plain Layout
Agent Program
\end_layout

\end_inset

.
 Its job is to take all commands directed to it and transform them into
 actions understood by the engine, and apply them to the agent that it controls.
\end_layout

\begin_layout Standard
To simplify the 
\family typewriter
AgentController
\family default
 design, it provides the method 
\family typewriter
PerformAction
\family default
, which makes it easy to execute actions on the agent it controls.
 When the 
\family typewriter
PerformAction
\family default
 is called, the 
\family typewriter
AgentController
\family default
 queues the action given through the method and puts the 
\family typewriter
AgentController
\family default
’s thread to sleep.
 Once the action has been executed by the engine, the 
\family typewriter
AgentController
\family default
 is woken up and returns from the 
\family typewriter
performAction
\family default
 method.
 All percepts received by the 
\family typewriter
AgentController
\family default
 during this time is stored on the 
\family typewriter
AgentController
\family default
 and can be easily accessed by the actual 
\family typewriter
AgentController
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename SystemFeatureAgentControllerSequenceDiagram.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
This sequence diagram shows the process of an AP taking control of agent
 through the 
\family typewriter
AgentManager
\family default
, and commanding it through the 
\family typewriter
AgentController
\begin_inset CommandInset label
LatexCommand label
name "fig:APConnectingToAndControllingAC"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The process of an AP taking control of an agent is illustrated in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:APConnectingToAndControllingAC"

\end_inset

.
 The AP calls the 
\family typewriter
AgentManager
\family default
 to locate the agent it wishes to assume control of.
 The agent is located through a string (its name) which is unique to it
 and ensures only one agent is taken.
 When the 
\family typewriter
AgentManager
\family default
 finds the correct agent, it will immediately generate a new 
\family typewriter
AgentController
\family default
.
 The AP will not gain access to the agent but instead it will gain access
 to the 
\family typewriter
AgentController
\family default
.
 Now that the AP possesses the 
\family typewriter
AgentController
\family default
, it will have the ability to send the 
\family typewriter
AgentController
\family default
 commands.
 These commands might not be understood by the engine if the APL is foreign
 enough to the engine’s own language and as such it is the duty of the 
\family typewriter
AgentController
\family default
 to convert these commands into actual actions which the engine can understand.
\end_layout

\begin_layout Standard
As this project is about working with GOAL in particular, we have created
 an extension for the 
\family typewriter
AgentController
\family default
 designed specifically to work with GOAL.
 Therefore any example shown here would be incomplete compared to the EIS/Goal
 implementation we have made.
 
\family typewriter
\emph on
[Remove paragraph?]
\end_layout

\begin_layout Subsubsection*
Summary
\end_layout

\begin_layout Standard
The agent controller is designed to be very lightweight, since we do not
 want to impose any restrictions that might limit an APL which we know nothing
 about.
 As such, the 
\family typewriter
AgentController
\family default
 is more akin to a convention or a design pattern for how interfacing with
 agents should occur.
 It provides the skeleton of how a link might be designed but does not impose
 any restriction of how should link should be setup.
\end_layout

\begin_layout Subsection
View
\end_layout

\begin_layout Standard
The engine is designed to assist the user in all parts of the process when
 making an environment, this also extends to the visualization of said environme
nt.
 However, since our goal is to have as few restrictions on the model as
 possible, our knowledge of that view’s representation is very limited.
\end_layout

\begin_layout Subsubsection
Concept
\end_layout

\begin_layout Standard
The view API which the engine provides consists of four abstract classes
 that are meant to be implemented by the user.
 The four classes can be seen in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ViewUMLView"

\end_inset

.
 We will go through each class and explain how they are meant to be implemented.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ViewUmlDomainDiagram.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
UML diagram of the view
\begin_inset CommandInset label
LatexCommand label
name "fig:ViewUMLView"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*

\family typewriter
XmasView
\end_layout

\begin_layout Standard
The 
\family typewriter
XmasView
\family default
 class is very simple; it only provides a single method that is required
 to be implemented.
 When the engine starts the view up it generates a thread for the view and
 the 
\family typewriter
Start
\family default
 method is the first method to be executed inside that thread.
 The start method should contain an endless loop that on a time interval
 updates the view.
 Another task of the implemented view is also to update its 
\family typewriter
ThreadSafeEventManager.

\family default
 The 
\family typewriter
ThreadSafeEventManager
\family default
 ensures that events sent from the model thread of the engine is not immediately
 executed, but instead lie dormant in the 
\family typewriter
ThreadSafeEventManager
\family default
 until the view thread is ready to execute them.
 How many events that one wishes to trigger is up to the user.
 We also provide the appropriate methods for the user to specify exactly
 how long he wishes to wait for the next event, or if it should timeout.
 The 
\family typewriter
ThreadSafeEventManager
\family default
 is very important to the view as without it, designing view code becomes
 complicated as one need to constantly ensure that no concurrency bugs has
 been applied to the system.
\end_layout

\begin_layout Paragraph*

\family typewriter
WorldView
\end_layout

\begin_layout Standard
The 
\family typewriter
WorldView
\family default
 class is added because of the long term benefits, as of now it provides
 nothing for the designer.
 However if we found benefits to add to the class, making it ahead of time,
 even if it is initially empty, can have many benefits as the project expands.
\end_layout

\begin_layout Paragraph*

\family typewriter
EntityView
\end_layout

\begin_layout Standard
Much like the 
\family typewriter
WorldView
\family default
 class, the 
\family typewriter
EntityView
\family default
 is also very minimal.
 However, it enforces certain things that the user of the engine should
 take care of.
 First, it automatically makes a 
\family typewriter
ThreadSafeEventQueue
\family default
 from the entity and attaches that 
\family typewriter
ThreadSafeEventQueue
\family default
 to the 
\family typewriter
ThreadSafeEventManager
\family default
 which should be provided by the 
\family typewriter
XmasView
\family default
.
 The idea is that all events the 
\family typewriter
XmasView 
\family default
wishes to listen on should be done by registering its triggers to the 
\family typewriter
ThreadSafeEventQueue
\family default
.
 This will ensure that when the view updates the 
\family typewriter
ThreadSafeEventManager
\family default
 all events pertaining to the specific entity is also updated on the 
\family typewriter
EntityView
\family default
’s triggers, but done so on the view thread instead of the model thread,
 separating the two threads completely.
\end_layout

\begin_layout Paragraph*

\family typewriter
ViewFactory
\end_layout

\begin_layout Standard
The 
\family typewriter
ViewFactory
\family default
 is meant to include all objects with low life cycle used by the view, it
 is also designed specifically to construct new 
\family typewriter
EntityViews
\family default
 during runtime of the engine.
 In order to know which 
\family typewriter
EntityView
\family default
 belongs to which 
\family typewriter
XmasEntity
\family default
 one is required to register all types of 
\family typewriter
XmasEntities
\family default
 and link it to its counterpart 
\family typewriter
EntityView
\family default
.
 For instance, assume you have a class inheriting 
\family typewriter
XmasEntity
\family default
 called 
\family typewriter
Wall
\family default
, and the 
\family typewriter
Wall
\family default
’s representation called 
\family typewriter
WallView
\family default
, then you need to manually register inside the 
\family typewriter
ViewFactory
\family default
 that 
\family typewriter
Wall
\family default
 is represented by 
\family typewriter
WallView
\family default
.
 
\end_layout

\begin_layout Subsubsection*
Summary
\end_layout

\begin_layout Standard
The view framework provides four classes each with their own advantages;
 they each represent a part of the model of engine.
 They are designed to assist the user in keeping his code threadsafe so
 that as few problems as possible arise.
\end_layout

\begin_layout Subsection
Engine Extensions
\end_layout

\begin_layout Standard
Since most of the engine is very abstract in functionality, we have made
 three extensions, which makes it easy to implement a tile based environment
 and communicating with EIS.
\end_layout

\begin_layout Subsubsection
Tile Extension
\end_layout

\begin_layout Standard
This extension represents the world as a two-dimensional array of tiles
 using what we will call a tile map.
 
\family typewriter
\emph on
[Elaborate on tile, that entities can move]
\family default
\emph default
 We have implemented it so that the tile in the center has the position
 
\begin_inset Formula $(0,0)$
\end_inset

.
 This means that all positions are given relative to the origo tile at 
\begin_inset Formula $(0,0)$
\end_inset

.
 As a consequence of this, a tile map must have odd dimensions, as it would
 otherwise not have a center tile.
 If the user tries to access a tile that is out of bounds (for example the
 tile at position 
\begin_inset Formula $(0,n+1)$
\end_inset

 in a 
\begin_inset Formula $n\times n$
\end_inset

 tile map), a tile containing a special entity signaling that the tile is
 not part of the world is returned.
 This ensures that querying the tile map for a tile at any position will
 never fail and always return a valid value.
 As well as accessing tiles at arbitrary positions, the tile map can be
 queried with a position and a range 
\begin_inset Formula $r$
\end_inset

, in which case a two dimensional array of size 
\begin_inset Formula $(2r+1)\times(2r+1)$
\end_inset

 is returned, containing the tiles in that square.
 
\family typewriter
\emph on
[Explain that it is relevant in eg.
 vision.
 Figure?]
\end_layout

\begin_layout Standard
In the tile extension, we have provided several modules that can be equipped
 to agents to make them better suited for inhabiting a tile based environment.
 For example, the 
\emph on
movement blocking-
\emph default
 and 
\emph on
vision blocking
\emph default
 modules apply to all entities with a physical presence in the environment;
 given another entity, they specify whether the entity they are attached
 to blocks the aforementioned entity's movement or vision, respectively.
 The 
\emph on
speed
\emph default
 module defines how long it takes for the entity to move to an adjacent
 square.
 
\family typewriter
\emph on
[Rewrite]
\end_layout

\begin_layout Paragraph*
Vision
\end_layout

\begin_layout Standard
The tile extension also provides means for seeing tiles around an entity
 via the 
\family typewriter
Vision
\family default
 module.
 All entities that are able to sense their surroundings also have a 
\family typewriter
VisionRange
\family default
 module which -- as the name implies -- defines how far (in tiles) the entity
 can see.
\end_layout

\begin_layout Standard
When the vision module is asked to return its percepts, it asks the world
 to build it a 
\family typewriter
Vision
\family default
 object, which it returns.
 The 
\family typewriter
Vision
\family default
 object uses an algorithm described in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:VisionAppendix"

\end_inset

 to assemble a set of mappings from positions (relative to the entity) to
 tile references.
 To determine whether a tile 
\begin_inset Formula $t$
\end_inset

 is visible to an entity 
\begin_inset Formula $e$
\end_inset

, we draw straight lines from each corner of 
\begin_inset Formula $e$
\end_inset

's tile to the corners of 
\begin_inset Formula $t$
\end_inset

.
 If such a line does not intersect with a tile that is vision blocking with
 respect to 
\begin_inset Formula $e$
\end_inset

, we say that the line 
\emph on
connects
\emph default
.
 If 
\begin_inset Formula $e$
\end_inset

's tile has any corner from which we can connect lines to all corners of
 
\begin_inset Formula $t$
\end_inset

, then 
\begin_inset Formula $t$
\end_inset

 is visible to 
\begin_inset Formula $e$
\end_inset

.
 If, however, 
\begin_inset Formula $t$
\end_inset

 is itself vision blocking, we require only two connecting lines, since
 at least one line would not have to travel through 
\begin_inset Formula $t$
\end_inset

, and as such not connect.
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[expand, add image]
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[move action, move event]
\end_layout

\begin_layout Subsubsection
EIS Extension
\begin_inset CommandInset label
LatexCommand label
name "sub:EIS-Extension"

\end_inset


\end_layout

\begin_layout Standard
The EIS extension provides means for communicating with an EIS instance
 over a socket, as well as serializing and deserializing percepts and actions
 encoded in an XML representation of EIS' 
\family typewriter
iilang
\family default
 format.
 The extension features custom a custom agent controller and manager, which
 have been developed to work well with EIS.
 
\end_layout

\begin_layout Standard
As EIS is implemented in Java and our engine is written in C#, information
 can not easily be passed between the two in a native manner.
 Instead, we have opted to have the two communicate over sockets.
 As EIS already supports formatting 
\family typewriter
iilang
\family default
 objects to XML, we chose this to encode information passed over the sockets.
 We have implemented our own 
\family typewriter
iilang
\family default
 object tree in C#, which implements XML serialization and deserialization
 (see appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:iiLang"

\end_inset

), as well as a Java class used to parse XML to 
\family typewriter
iilang
\family default
 objects.
 Furthermore, we have implemented special package streaming objects in both
 C# and Java, which sends the size of a payload before the actual data when
 streaming XML over sockets
\family typewriter
\emph on
[Elaborate]
\family default
\emph default
.
 This allows us to detect when an XML message has been completely received.
 This means that designers wanting to use EIS with our engine should implement
 our accompanying Java libraries, as well as the EIS engine extension.
\end_layout

\begin_layout Standard
In order for an EIS instance to connect to an agent controller, it must
 connect to a socket which is known by both the EIS instance and the engine
 at runtime.
 The agent manager listens to this socket and accepts the connection.
 As the EIS instance connects, it receives a new socket which can be used
 to communicate with the agent controller.
 It now sends an XML message with the name of the agent on this socket,
 and the agent manager constructs an agent controller tied to this name
 and socket.
 The controller and the EIS instance now have their own private socket connectio
n to communicate on, and the agent manager proceeds to listen for other
 APL instances requesting an agent controller.
\end_layout

\begin_layout Standard
The EIS instance can now proceed to send actions to be executed to the agent
 controller.
 When such an action is received, the controller enqueues it, and sleeps
 till it is finished, at which point it resumes listening for actions on
 the socket.
 The request to return all percepts is just an action with the name 
\family typewriter
getAllPercepts
\family default
, which causes the controller to gather all available percepts from the
 attached agent and sent them to the EIS instance via the socket.
 Note that by default, this is the only way perepts are sent; percepts are
 returned in response to no other actions.
 Since the agent controller effectively blocks on actions, the EIS instance
 can not have the controller queue other actions or return percepts when
 it is executing an action that takes time, such as the tile extension's
 move action (this is a restriction imposed by the agent controller base
 class as described in section 
\family typewriter
\emph on
[insert section number]
\family default
\emph default
, as it is the default behaviour of the 
\family typewriter
performAction
\family default
 method).
 This execution sequence is very simple, but has some downsides.
 Consider, for example, that two agents wish to communicate with each other
 through the engine via a 
\family typewriter
talk
\family default
 action.
 It could be that agent 
\begin_inset Formula $a_{1}$
\end_inset

 wanted to ask agent 
\begin_inset Formula $a_{2}$
\end_inset

 whether a certain tile was a desirable place to go.
 In that case, 
\begin_inset Formula $a_{1}$
\end_inset

's APL would have the action queued in the engine, which would execute it
 and place the question in 
\begin_inset Formula $a_{2}$
\end_inset

's mailbox.
 If, however, 
\begin_inset Formula $a_{2}$
\end_inset

 had just started a lenghty action, such as moving, its APL would not get
 notified that it had been asked a question until the move was complete,
 and the controller could respond to the 
\family typewriter
getAllPercepts
\family default
 action.
 This introduces quite some delay in performing such actions, which are
 rather important in a multi-agent system.
 
\end_layout

\begin_layout Standard
To remedy this, the system could be designed such that the controller instead
 blocked on the call to return all percepts until the agent had some new
 percepts available.
 In the communication example described above, 
\begin_inset Formula $a_{2}$
\end_inset

 would immediately perceive that 
\begin_inset Formula $a_{1}$
\end_inset

 had asked it a question, which would cause its controller to send all 
\begin_inset Formula $a_{2}$
\end_inset

's percepts (including the question) to the waiting EIS instance.
 Assuming that the corresponding AP prioritizes answering the question,
 
\begin_inset Formula $a_{1}$
\end_inset

 would have its answer in the shortest possible amount of time.
 In general, allowing agents to perform multiple actions at the same time
 makes the world more responsible in a number of ways.
 As another example, agents in a tile based world (or any world that allows
 vision) could subscribe to events on tiles they could see, and be able
 to respond when eg.
 an enemy moved into one of them.
 This would allow them to communicate the offenders position to nearby agents,
 or simply give the AP a chance to preemptively figure out what the best
 possible action would be to execute next.
 
\family typewriter
\emph on
[Move to Implementation]
\end_layout

\begin_layout Standard
This method does have some problems.
 How, for example, does 
\begin_inset Formula $a_{2}$
\end_inset

's AP know that it should prioritize answering the question, and not, say,
 command the agent to begin a new move action? Since 
\begin_inset Formula $a_{2}$
\end_inset

 is already in the middle of a move, it would most likely break the rules
 of the environment.
 To remedy this, the agents need to return the action(s) they are currently
 executing as percepts, and the AP would have to consider these when choosing
 actions.
 For larger environments and agent programs, this would complicate the agent
 logic and percept pool.
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Actions and conversion]
\end_layout

\begin_layout Paragraph*
EIS and Tile Extension
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Converters and actions for working with EIS in a tile based environment]
\end_layout

\begin_layout Subsection
Usage Example (reference implementation)
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Missing]
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Subsection
Architecture
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Missing]
\end_layout

\begin_layout Subsection
Model
\end_layout

\begin_layout Subsubsection
World
\end_layout

\begin_layout Standard
To be able to unambiguously reference an entity, they are assigned an 
\family typewriter
id
\family default
 (represented as a number) in the engine.
 This is relevant when, for example, a backend APL such as GOAL executes
 an action involving other entities than the agent it is controlling.
 In this case, the entity's position can be amiguous, since several agents
 may very well occupy the same spot in the world.
\end_layout

\begin_layout Standard
To hold references to all entities in the environment, the 
\family typewriter
XmasWorld
\family default
 class contains a set of mappings (a C# 
\family typewriter
Dictionary
\family default
) from 
\family typewriter
id
\family default
s to entities.
 Since all agents have a name, it also contains mappings from names to agents.
 
\end_layout

\begin_layout Standard
When an entity is added to the world, the variable holding the last used
 
\family typewriter
id
\family default
 is increased by one, and the entity is associated with this number.
 This ensures unambiguity, since no number can be used twice.
 However, it does impose a limit on the number of entities that can be added
 to the world.
 We have represented the 
\family typewriter
id
\family default
 as a 64 bit unsigned integer (C#
\family typewriter
 ulong
\family default
 type), so it supports adding more than 
\begin_inset Formula $1.8\times10^{19}$
\end_inset

 entities.
 In an environment that is meant to run indefinetely, and where entities
 are added and removed often (such as a server based website indexing tool),
 this limit may be a concern.
 
\end_layout

\begin_layout Standard
The process of assigning 
\family typewriter
id
\family default
s to entities is handled in the 
\family typewriter
AddEntity
\family default
 method, which takes as arguments the entity to be added and an 
\family typewriter
EntitySpawnInformation 
\family default
object, containing the desired position of the entity in the world, and
 any other relevant information, such as initial state.
 However, this only occurs after the user-implemented method 
\family typewriter
OnAddEntity
\family default
 is called with the entity and spawn information as arguments, and has returned
 success.
 This method is overridable by the designer, and can be used to ensure that
 entities are added properly to the custom world, or not at all.
 For example, if the world has the restriction that no two entitites can
 start in the same position, 
\family typewriter
OnAddEntity
\family default
 can be implemented so as to return failure when an the entity in question
 would be spawned in an occupied position.
 Alternatively, it may correct the error, for example by placing the entity
 in an adjacent, unoccupied square and return success.
 In any case, the 
\family typewriter
AddEntity
\family default
 method propagates the return value from 
\family typewriter
OnAddEntity
\family default
 to its caller when it returns.
\end_layout

\begin_layout Standard
The 
\family typewriter
RemoveEntity
\family default
 method dereferences the entity by removing itself and its 
\family typewriter
id
\family default
 from the previously mentioned set of mappings.
 Similarly to the 
\family typewriter
AddEntity
\family default
 method, it calls the user-supplied 
\family typewriter
OnRemoveEntity
\family default
 method, and returns its return value.
 
\family typewriter
\emph on
[entity.OnLeaveWorld?]
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[pseudo code for AddEntity, RemoveEntity?]
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[abstract methods in System Features?]
\end_layout

\begin_layout Subsubsection
Entities and Entity Modules
\end_layout

\begin_layout Standard
When designing the 
\family typewriter
Entity
\family default
 class, we wanted to detach the properties and behaviour of entities from
 the class itself, and segmentize them into smaller, succinct objects.
 In essence, we wanted to be able to construct an entity that could, for
 example, move and speak by assembling it from a movement object and a speaking
 object.
 In object oriented programming languages such as C#, problems like this
 are typically accomplished by means of inheritance.
 It would indeed make sense to let a 
\family typewriter
MovingAndSpeakingAgent
\family default
 class inherit from the 
\family typewriter
MovingAgent
\family default
 and 
\family typewriter
SpeakingAgent
\family default
 classes, which would then provide the desired behaviour.
 Unfortunately, C# does not support multiple inheritance; a class can not
 directly inherit from more than one class, although it can inherit multiple
 interfaces.
 Instead of using inheritance, we designed the module system described in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:SysFeatEntities"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Events and Triggers
\end_layout

\begin_layout Standard
This section will cover the inner workings of how events and triggers are
 connected, as well as detail why we designed it the way we did.
 We will also cover the exact procedure when an event is raised, to defuse
 any confusion there might be as to what happens inside the engine.
\end_layout

\begin_layout Paragraph*
Explanation
\end_layout

\begin_layout Standard
By themselves, events are not particularly complicated since they are essentiall
y just data structures that are transferred to all its listeners upon triggering.
 As such we shall do a close examination of how exactly the
\family typewriter
 EventManager 
\family default
works.
\end_layout

\begin_layout Standard
The 
\family typewriter
EventManager
\family default
 is tethered through the engine to all entities that are inside.
 Whenever an entity has an event raised on it, it is copied to the event
 manager which also raises the event.
 The intent is to minimize the number of events needed to cover a single
 case.
 To be clear on how exactly this transpires, we have drawn a sequence diagram.
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[SHOW Sequence diagram of an event being raised on an entity and then transferre
d to the event manager]
\end_layout

\begin_layout Standard
As shown on this sequence diagram, an action -- in this case a move action
 -- raises an 
\family typewriter
EntityMovedEvent
\family default
 on a given entity.
 The entity then calls all triggers registered to it, where the trigger
 also contain the event being raised.
 After this, the entity informs the 
\family typewriter
EventManager
\family default
 that an event has been raised on it, which causes the 
\family typewriter
EventManager
\family default
 to also call all its registered Triggers with the given Event.
 Once all relevant triggers have been informed of the Event being raised,
 the procedure is complete and the 
\family typewriter
EventManager
\family default
 returns to its dormant state.
\end_layout

\begin_layout Standard
In the case of events that are not linkable to a specific entity such as
 an “Engine Close Event”, the event is raised purely on the 
\family typewriter
EventManager
\family default
 itself.
 Otherwise, the process is exactly the same as above, except that no particular
 entity is involved.
\end_layout

\begin_layout Paragraph*
Considerations
\end_layout

\begin_layout Standard
As there were many considerations that went through our design process,
 we will take each component of this area and break down why exactly why
 we designed it as we did.
\end_layout

\begin_layout Subparagraph*
Problems of C# events and why we chose to design our own events
\end_layout

\begin_layout Standard
The language which our engine is written in is C#, one of the fantastic
 things about C# is that events is built into the language.
 As such it may come as a surprise that we have chosen to re-implement events
 ourselves.
 However, while the name be the same, the intent between C# events and our
 events is so different that it is impossible to compare the two.
 The intent behind C# events is to keep maintenance on single objects, so
 that changes to a given object can affect its linked objects without having
 to be designed specifically to do so.
 This allows for really decoupled projects and is what makes object maintenance
 in C# quite easy.
 However our events are not meant for such low-level tasks.
 Instead they are meant to allow reactions to occur in response to other
 actions.
 Furthermore, C# actions are bound to a specific class, and can only be
 fired inside methods of an instantiation of the specific class.
 The events we have designed are meant to be raised by all types of class
 that wish to signal such an event has occurred.
\end_layout

\begin_layout Standard
To give an idea of what sort of problems that would arise from using C#
 events, one need only look at how global events would have to be implemented.
 Since Events using C# are linked to a specific class, which would essentially
 mean that the EventManager class would need to be setup for every single
 event the engine is capable of running.
 What this basically has accomplished is to couple a single class into the
 entire workings of an engine, this makes for poor programming design in
 more than one way and greatly reduces productivity.
 It also makes the engine difficult to extend and modify at a later time
 since the design would be practically hardcoded into it.
 
\family typewriter
\emph on
[Explain in detail / rewrite paragraph]
\end_layout

\begin_layout Subparagraph*
Improvements of events
\end_layout

\begin_layout Standard
As of now, our events are not tied to being 
\family typewriter
EntityEvent
\family default
s or 
\family typewriter
EnvironmentEvent
\family default
s like actions are, however this might have been a wrong move on our part.
 The problem is that the user of the engine might be unclear as to which
 is what, currently the difference lies in the name convention used for
 events.
 For instance, it is clear from the name that the 
\family typewriter
EntityMovedEvent
\family default
 can be tied to a specific entity.
 In the case of the 
\family typewriter
AddedEntityToEngineEvent
\family default
, however, there is some ambiguity, as the event is clearly speaking about
 a single entity, but as the entity is only just added it would have been
 impossible for any trigger to be registered to it.
 If one was to make improvements to the event design this would be one change
 that was worth looking into.
\end_layout

\begin_layout Subparagraph*
Triggers
\end_layout

\begin_layout Standard
The trigger design came about as a necessity for providing a way for the
 user to easily design reactions to a given event.
 The trigger design is very minimalistic except for the fact that it has
 a condition.
 We designed it with the condition because we wanted it to be obvious how
 unwanted events should be handled.
 Furthermore it also helps to split up the code containing if the action
 should be executed away from the action itself allowing for more readable
 code.
 
\end_layout

\begin_layout Standard
Another way the triggers could have been designed would be if the user simply
 registered lambda functions (anonymous function), this would help reduce
 the amount of classes a user should know and understand.
 However we preferred to encapsulate this into what we call the Trigger,
 since we wanted to have the ability to expand the capability of the trigger
 at a later time.
\end_layout

\begin_layout Standard
In short, triggers are a simple design that gives the engine logic a lot
 of flexibility.
 
\end_layout

\begin_layout Paragraph*
Summary
\end_layout

\begin_layout Standard
Events and triggers might be a hassle to setup and design, but in return
 they provide the engine with a lot of flexibility.
 Without Events the engine would suffer greatly and all actions would be
 required to be bogged down with a lot of extra logic.
 This would not only remove the modularity of the engine but also make using
 the engine more error-prone.
\end_layout

\begin_layout Subsubsection
Actions
\end_layout

\begin_layout Standard
As we already went through what actions can be used for, this section will
 instead focus on the idea behind actions, and how we implemented them.
 It will furthermore cover the entire life span of an action object.
\end_layout

\begin_layout Paragraph*
Explanation
\end_layout

\begin_layout Standard
An action -- or 
\family typewriter
XmasAction,
\family default
 as it is called in our engine
\family typewriter
 
\family default
-- is a class which provides an API for performing state changes inside
 the engine, while also ensuring that only one action at a time is being
 executed.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImplementationActionQueuingExplanation.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ImplementationActionQueuingExplanation"

\end_inset

A sequence diagram describing the execution of an action.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ImplementationActionQueuingExplanation"

\end_inset

 it starts with the 
\family typewriter
XmasModel
\family default
 running an endless loop that tells the 
\family typewriter
ActionManager
\family default
 to execute all newly queued actions.
 The 
\family typewriter
ActionManager
\family default
 then takes all the actions from a thread safe list and places them in a
 local list.
 After this, each action is executed individually, putting the action that
 is being executed in a running state, this state will not change before
 the actions 
\family typewriter
Completed
\family default
 method is called.
 Once an action has been properly executed, it will be changed to a completed
 state and will be properly disposed of.
 When the last action has been executed by the 
\family typewriter
ActionManager
\family default
, the call to 
\family typewriter
ExecuteActions
\family default
 returns and 
\family typewriter
XmasModel
\family default
 will put the thread in a waiting state.
 The 
\family typewriter
XmasModel
\family default
 will remain in a waiting state until a new action has been placed on the
 queue; this prevents it from busy waiting when no actions are to be executed.
\end_layout

\begin_layout Paragraph*
Considerations
\end_layout

\begin_layout Standard
The way that action completion is designed might seem tedious in that it
 has to call the special method 
\family typewriter
Completed
\family default
 on each action.
 However it is quite necessary as the completion of the execute method call
 does not guarantee that a method is completed, for instance in the case
 of non-instantanious actions, as explained in the example below.
 
\end_layout

\begin_layout Standard
Consider the action of moving from one place to another.
 In this case the move action would need to create a timer to give the idea
 that the move action had a speed.
 As we can’t halt other actions during this time it is paramount that the
 
\family typewriter
Execute
\family default
 method is released so that other actions can be executed during this period.
 
\end_layout

\begin_layout Standard
This is also how the move action is designed in our reference implementation,
 the algorithm is as follows
\end_layout

\begin_layout Enumerate
The move action is put on the queue 
\end_layout

\begin_layout Enumerate
The move action sets up a timer on a different thread and finishes its execution
\end_layout

\begin_layout Enumerate
The timer is fired after a given time, and places a new action on the queue
\end_layout

\begin_layout Enumerate
The new action performs the actual move, and calls the 
\family typewriter
Completed
\family default
 method of its parent Action (the 
\family typewriter
MoveAction
\family default
)
\end_layout

\begin_layout Standard
As one can see, the problem in this design is the redundancy created by
 having to call the method 
\family typewriter
Completed 
\family default
on each execution.
 This might not seem like a problem but it is problematic in a few ways.
 First and foremost it adds complexity in usage of the engine, a person
 with no knowledge of using the engine would not intuitively deduce the
 correct way to make and use actions.
 Thus it creates a second problem: there is no way to determine if an action
 is correctly constructed during compile time.
 This means bugs will naturally accumulate during extended use, even if
 a user has experience and foreknowledge forgetting even for a single action
 can be crucial.
 This is because running actions use resources and if never completed the
 resources of the actions are never released.
 For instance let us assume the 
\family typewriter
MoveAction
\family default
 
\family typewriter
Completed
\family default
 method is never called, the result of this is that it is stored in the
 
\family typewriter
ActionManager
\family default
 as 
\family typewriter
Running
\family default
.
 Now let us assume that this move action is continuously being executed
 by hundreds if not thousands of agents.
 As each action is never released the memory stored for each action is never
 released and an unintentional memory leak is thus created.
\end_layout

\begin_layout Standard
Another way we could have chosen to implement the action completion process,
 is the usage of child action.
 Imagine if an action could generate new actions that were linked with it,
 thus the completion of an action would be tied to the fact that all its
 child actions had been executed and not the arbitrary call of a 
\family typewriter
Complete
\family default
 method.
 This could undoubtedly provide new problems to overcome and as such we
 have not fully followed this path, however given more time to study the
 consequences of this design would reveal whether or not this is a better
 design.
 
\end_layout

\begin_layout Paragraph*
Summary
\end_layout

\begin_layout Standard
A lot of the considerations when designing the action all comes down to
 the reliance on user to clean up the Action, which is generally not good
 from a design perspective; it is always preferable that used data is cleaned
 up automatically when it is out of scope.
 However it is not all bad as this design does guarantee a flexible usage
 of the actions; it provides more control to the user which might give the
 user abilities to do certain things which would otherwise be denied within
 the engine.
 This is also why this design method was chosen as our philosophy in the
 engine design was to minimize limitations as much as possible while still
 providing the features we thought necessary to fulfill the engine's goal.
\end_layout

\begin_layout Subsection
Agent Controller
\end_layout

\begin_layout Standard
The agent controller is designed specifically to be able to accommodate
 all types of APL.
 This means that a lot of special care had to be taken in order for us to
 impose as few restrictions as possible.
 This section will focus on the different designs we went through and why
 we eventually landed on the design we have now.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ImplementationAgentControllerSequenceDiagram.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
This image details exactly how an 
\family typewriter
AgentManager
\family default
 Processes incoming requests from an outside AP 
\begin_inset CommandInset label
LatexCommand label
name "fig:ImplementationAgentControllerSequenceDiagram"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Explanation
\end_layout

\begin_layout Standard
The 
\family typewriter
AgentManager
\family default
 is designed to run separately from the engine’s model thread, which means
 it has the ability to take all the time needed to properly connect to an
 outside AP, same goes for the 
\family typewriter
AgentController
\family default
.
 This means that when an 
\family typewriter
AgentManager
\family default
 generates a new 
\family typewriter
AgentController
\family default
 to be used by the AP, it also generates a new thread which the 
\family typewriter
AgentController
\family default
 is executed on.
 In the System Features section we covered how 
\family typewriter
AgentController
\family default
s are used.
 Here we will elaborate on the exact process.
 In fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ImplementationAgentControllerSequenceDiagram"

\end_inset

, a sequence diagram is shown that looks familiar to the one shown in the
 system features.
 However there are a few key differences.
 First, this sequence diagram shows the complete life cycle of an 
\family typewriter
AgentManager
\family default
, since the 
\family typewriter
AgentManager
\family default
 is running on its own thread it does not care about blocking until work
 needs to be done and the only kind of work it is responsible for is ensure
 that 
\family typewriter
AgentController
\family default
s are generated for APs in need of them.
 Second, it also details that 
\family typewriter
AgentController
\family default
s are in fact generated by the 
\family typewriter
AgentManager
\family default
 with its own thread.
\end_layout

\begin_layout Subsubsection*
Considerations
\end_layout

\begin_layout Standard
The 
\family typewriter
AgentManager
\family default
 went through many design iterations in order to arrive at its present state.
 Originally, the 
\family typewriter
AgentManager
\family default
 was called 
\family typewriter
AgentServer
\family default
.
 The reason was that for another language to interface with the language
 of the engine -- C# -- there must be a universal way of connecting the
 two languages.
 A way in which practically no languages was prohibited from interacting,
 and as we thought such a way could only be achieved through a TCP connecting
 since the protocol for TPC connections is very old and as such usable in
 most languages by far.
 While it is true that probably almost all languages do require a TCP connecting
 in order for them to work with our engine, it is not true for languages
 that the engine understand, considering that all the .NET platform languages
 works together very well.
 For example, you could use the functional programming language F#, which
 also runs on the .NET platform.
 As such, if we imposed that all 
\family typewriter
AgentManager
\family default
s are 
\family typewriter
AgentServer
\family default
s, it would be required to setup a server just for using a language which
 the engine already understands.
 
\family typewriter
\emph on
[Consider rewriting paragraph from another standpoint: AgentManager is more
 general, less restrictive than AgentServer]
\end_layout

\begin_layout Subsubsection*
Summary
\end_layout

\begin_layout Standard

\family typewriter
AgentManager
\family default
 and 
\family typewriter
AgentController
\family default
 is designed as a framework for making an interface between an APL and the
 engine.
 They are intentionally made very lightweight so that they do not prohibit
 the any special requirements of any given APL.
\end_layout

\begin_layout Subsection
View
\end_layout

\begin_layout Standard
As the view our engine provides is only a framework for making an actual
 view, it limits what can be said about its implementation.
 What this section will focus on is why we chose to design the view in this
 manner and how we provide ways to ensure that the view can be executed
 on a different thread while not being affected by its problems.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ViewImpThreadSafeSequenceDiagram.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sequence diagram show how events triggered on the model is stored and put
 on hold until the view thread is able to process them
\begin_inset CommandInset label
LatexCommand label
name "fig:ThreadSafeSequenceDiagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Design
\end_layout

\begin_layout Standard
The view design for the engine was never meant to be an actual view, this
 would limit the potential of what could be done so we are rather content
 with not providing more than the skeleton for making a proper view.
 The idea is that the actual implementation of a view should be part of
 some extension to make a view that displays graphics or a view that shows
 a console, it should never be a core part of the engine.
 The core engine should only provide what all views need, this means that
 if just a single view is restricted by our design then our design is flawed.
\end_layout

\begin_layout Subsubsection
Thread Safety
\end_layout

\begin_layout Standard
One thing all views have in common is the dangers of having code that is
 not thread safe, by having two threads run through the same address space
 at the same time, the guarantee of a race condition or deadlock is very
 high.
 This makes programming a view rather difficult.
 To combat this problem, we came up with the 
\family typewriter
ThreadSafeEventManager
\family default
 and the 
\family typewriter
ThreadSafeEventQueue
\family default
.
 These classes both assist with ensuring that the model thread is never
 involved in the view thread’s business.
 The way the 
\family typewriter
ThreadSafeEventManager
\family default
 works is by storing all events triggered by the EventManager of the model,
 the events data are all kept safe and the order in which the events was
 triggered is also kept.
 The idea is that when the view thread is not performing any actions, such
 as when it is in sleep mode between a draw update, instead of sleeping
 it will call the 
\family typewriter
ThreadSafeEventManager
\family default
 and tell it to begin executing.
 The process works by running the 
\family typewriter
ThreadSafeEventQueue
\family default
 that had one of its events trigger and tell it to execute.
 When all 
\family typewriter
ThreadSafeEventQueue
\family default
 are empty then that mean that there are no longer any events waiting to
 be executed on the view thread.
 Since views are only interested in seeing the changes to the world and
 not how the changes came about, then that means that the views only need
 access to the events and not the actions.
 To see a sequence diagram of this process look at fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ThreadSafeSequenceDiagram"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
The view design is mostly focused on ensuring that the user of the engine
 should deal with as few threading problems as possible as such we have
 developed two classes 
\family typewriter
ThreadSafeEventQueue
\family default
 and 
\family typewriter
ThreadSafeEventManager
\family default
 these both make it possible for the view to trigger events when the thread
 is free from other duties, instead of relying on the model thread to also
 handle view event updates.
 
\end_layout

\begin_layout Subsection
Engine Extensions
\end_layout

\begin_layout Subsubsection
Tile Extension
\end_layout

\begin_layout Paragraph*
Vision
\end_layout

\begin_layout Standard
As the basic rules for which tiles can be seen from where have been explained
 in the System Features section, we will now turn our attention to how corners
 are connected with each other.
 
\end_layout

\begin_layout Standard
Recall that a corner 
\begin_inset Formula $c_{1}$
\end_inset

 on a tile 
\begin_inset Formula $t_{1}$
\end_inset

 connects to a corner 
\begin_inset Formula $c_{2}$
\end_inset

 of another tile 
\begin_inset Formula $t_{2}$
\end_inset

 if a straight line can be traced from 
\begin_inset Formula $c_{1}$
\end_inset

 to 
\begin_inset Formula $c_{2}$
\end_inset

 without intersecting with a tile that is blocking the line.
 In the tile extension, a tile is blocking the line if it contains an entity
 that is movement blocking with respect to the entity looking from 
\begin_inset Formula $t_{1}$
\end_inset

.
 Additionally, the tile 
\begin_inset Formula $t_{2}$
\end_inset

 is visible from 
\begin_inset Formula $t_{1}$
\end_inset

 if at least one corner of 
\begin_inset Formula $t_{1}$
\end_inset

 connects to at least three corners of 
\begin_inset Formula $t_{2}$
\end_inset

.
 If 
\begin_inset Formula $t_{2}$
\end_inset

 is vision blocking, only two corners of 
\begin_inset Formula $t_{2}$
\end_inset

 need be connected to.
 In its most simple form, the algorithm iterates over all the tiles in the
 agent's visible range, and returns a collection containing just those satisfyin
g the above condition.
 
\end_layout

\begin_layout Standard
The interesting part of the algorithm is this: how do we find all the tiles
 a line from one corner to another passes through? 
\family typewriter
\emph on
[Figure]
\family default
\emph default
 To accomplish this, we find the slope of the line as 
\begin_inset Formula $\left|\frac{v_{x}}{v_{y}}\right|$
\end_inset

, where 
\begin_inset Formula $v$
\end_inset

 is the vector describing the line.
 If either 
\begin_inset Formula $v_{x}$
\end_inset

 or 
\begin_inset Formula $v_{y}$
\end_inset

 is zero, the line only passes between tiles, and it is handled as a special
 case.
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Explain that it is similar to that other algorithm (name?)]
\end_layout

\begin_layout Subsection
Reference Implementation
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Missing]
\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Missing]
\end_layout

\begin_layout Subsection
Unit Testing
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Missing]
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
In this section we will discuss the major considerations we faced during
 the project, as well as the choices we took in accomplishing our goals,
 and how we could have otherwise reached them.
\end_layout

\begin_layout Subsection
Generality of the engine
\end_layout

\begin_layout Standard
One of the major goals of this project was to make the engine as general
 as possible.
 This includes the ability for the designer to implement any kind of environment
, displayed any way he wants, and controlled by whatever APL he would like
 to use.
 In this section we will discuss how these three vital parts of our engine
 lives up to this goal.
\end_layout

\begin_layout Standard
For the engine to be general means it has the ability to adapt to any needed
 situation.
 The only restriction is that these situations are based on Multi agent
 Environment, other than that nearly any situation should be coverable by
 the engine.
 For instance if one wishes to use the engine to make a computer game, then
 the view must be able to support a graphical display and the world of the
 engine must have the ability to be changed to a 3d-world.
 But if instead one wishes to make an engine for searching documents for
 spelling errors, then the world should be extendable to a text-document.
 Furthermore to be general also means that the engine should be used to
 work with any other APL, so regardless if the APL is goal, Jason or F#
 the engine should have the ability to be adapted into working with either
 of those languages.
\end_layout

\begin_layout Standard
In many cases, the shortest path to a general system is removing restrictions.
 Unfortunately, features are often restrictive in nature; the most general
 system of all is one that is completely featureless.
 Thus, it is often åa trade-off between features and generality.
\end_layout

\begin_layout Subsubsection*
Model
\end_layout

\begin_layout Standard
For the model to be general, it should be capable of representing a world
 as any possible data structure.
 Additionally, the objects inhabiting it should be as general as possible,
 allowing them to be defined in a way that makes sense in the context of
 the world.
 
\end_layout

\begin_layout Standard
We have accomplished this by imposing as few restrictions as possible on
 these objects.
 For example, as described in section 
\family typewriter
\emph on
[System Features.World]
\family default
\emph default
, a world in the engine has no data associated with it by default, leaving
 the modelling of it completely in the hands of the designer.
 The only restriction on the world is the idea that all entities should
 have a postition in it, although the position object is completely general
 itself.
 
\family typewriter
\emph on
[Environments where postition does not matter?]
\end_layout

\begin_layout Standard
Initially, we toyed with the idea of equipping the world with a graph as
 the default representation of the environment, since it is a very general
 data structure in the sense that it can be used to describe other data
 structures.
 The problem with this approach is that a graph may not be the best representati
on of any given world.
 In the case of a tile based world, for example, a two dimensional array
 is more feasible, since this is its natural representation.
 Ultimately, we chose to impose no restrictions on the data structure used,
 and instead rely on the use of extensions to model environments.
\end_layout

\begin_layout Subsubsection*
Interfacing with APLs
\end_layout

\begin_layout Standard
One of the major problems in designing an interface that works with different
 APLs is that the order in which they queue actions and queries percepts
 may be different from APL to APL.
 In effect, they do not share a common execution protocol.
 This means that we cannot provide a general method for communicating with
 any AP.
 Instead, as with other parts of the engine, the intent is to allow for
 extensions capaple of interfacing with different APLs in any way they see
 fit.
\end_layout

\begin_layout Standard
It could be argued that using the notions of percepts and actions serves
 to limit the universality of the engine.
 These are, however, general concepts for interacting with an intelligent
 agent.
 They are basically the input and output of the agent; it perceives the
 state of the world, and produces an action based on this information.
 
\family typewriter
\emph on
[Explain why the functions of an agent can not be reduced any further (why
 they are the basis for an agent), refer to AIMA]
\family default
\emph default
 As such, they are essential to interacting with an agent, and incorporated
 in all agent programming languages we are aware of.
\end_layout

\begin_layout Subsubsection*
View
\end_layout

\begin_layout Standard
For the view to be considered general it is paramount that the design of
 the view is not being restricted in anyway, this is done by keeping anything
 in the view very minimalistic.
 By minimalistic we mean that the view only provides about four classes
 and they only provide a little about of business logic.
 If we had narrowed down how exactly a view should be designed such as requiring
 a frame for which the view is projected on.
 This might have made implementations of the view easier as tools to draw
 on frames could be pre-implemented into the engine.
 We did not want to do this since we think that restrictions should be non-exist
ent .However this also poses a potential problem in that it is so minimalistic
 that we barely provide anything for the user, and leave the user to the
 task of making the view by themself.
\end_layout

\begin_layout Subsubsection*
Solving the Problems of Generality
\end_layout

\begin_layout Standard
As evident when discussing how to make the engine general and how to make
 it work with as many situations as possible, the problem arises that the
 workload for the user gets increased.
 This is because whenever we remove something from the engine in order to
 ensure that we impose no restrictions, we run the risk of removing something
 that made the life of the user easier, since they would not have to re-implemen
t it themself.
 To combat this problem we moved everything that added value to the engine
 but imposed a restriction to the Engine Extensions project.
 The idea would be that while the extensions was not part of the core engine,
 they would be part of what we delivered with the engine.
 We saw this as the best of both worlds, not only do we ensure that the
 engine is not being restricted, but at the same time if the user did not
 mind some restrictions, then they would be able to find a suitable extension
 among the ones we provide.
 As of now the only extensions we have are those needed for the reference
 implementation, but our long term plan would be to add more extensions
 if possible.
\end_layout

\begin_layout Subsection
Model View Controller Design Pattern
\end_layout

\begin_layout Standard
The model view controller design pattern is one of the older design patterns
 within software design; its purpose is to ensure that the developer does
 not deal with multiple issues at once, and instead is able to focus on
 one task of the project at a time.
 We chose to base our engine on the MVC pattern because we also do not want
 the user of the engine to be tasked with multiple issues at once.
 Without the MVC pattern, the user could be confused about how for instance
 they should design a controller for an APL, and perhaps they would mistakenly
 design it tailored to specific actions.
 If the user did this, they would have to write new actions to perform the
 same task for each new APL they encountered, which would increase code
 redundancy.
 As the designers of this engine we wanted to ensure those kinds of mistakes
 do not happen.
 The way we enforce this is by forcing the MVC pattern.
 Since by forcing the MVC pattern we force the user to think about how they
 should construct the implementation of the engine’s abstract classes.
 However since it is only a pattern, the user can still make bad design
 decisions as we impose no restrictions.
 As most bad design decisions comes from making an easy implementation of
 something, we hopefully reduce the number of times they are made by making
 bad decisions harder.
 
\family typewriter
\emph on
[rewrite sentence?]
\end_layout

\begin_layout Subsection
Test Driven Development
\end_layout

\begin_layout Subsection
Choice of Technologies
\end_layout

\begin_layout Subsubsection*
The XMAS Engine
\end_layout

\begin_layout Standard
We have chosen to implement the engine in C#, which runs on the .NET platform.
 While Java has a strong presence in multi-agent system development -- as
 it is used by established APLs such as Jason, as well as the EIS standard
 -- we have a subjective preference for C#.
 In general, C# is a newer and more modern programming language with better
 facilities for writing comprehensive and maintainable code, and provides
 some features usually only found in functional programming languages.
 Additionally, .NET code can be executed across platforms, thanks to the
 Mono project 
\family typewriter
\emph on
[Link to Mono]
\family default
\emph default
, although the newest version of .NET (v4.5) has not been ported at the time
 of this writing.
 Although developing our reference implementation would have been simpler
 had we used Java, opting out of this in favor of C# gave us the opportunity
 to test how well our engine interfaced with programs not written in the
 same language.
 
\end_layout

\begin_layout Subsubsection*
Reference Implementation
\end_layout

\begin_layout Standard
As our reference implementation was developed to showcase and test our engine,
 we aimed to implement it using the most commonly used agent programming
 language.
 Since EIS can be interfaced with many different APLs, this seemed like
 the obvious choice.
 If the engine could be shown to work with EIS, any APL supported by EIS
 would work by extension.
 Initially, we considered writing a J# (.NET bindings for the Java Language)
 module, which would work natively with both our engine written in C#, and
 the EIS implementation written in Java.
 However, we felt that this would remove the difficulties of communicating
 with an entirely different platform.
 This difficulty is important to face, since 
\end_layout

\begin_layout Subsection
Comparison to other Environment Construction Tools
\end_layout

\begin_layout Standard
Comparison to JaCaMo, EIS
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Subsection
Usability
\end_layout

\begin_layout Standard

\family typewriter
\emph on
[Missing]
\end_layout

\begin_layout Section
\start_of_appendix
Domain Model UML Diagram for XMAS Model 
\begin_inset CommandInset label
LatexCommand label
name "sec:Domain-Model-UML"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename xmas_domain_model_uml.png
	width 120col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:DomainModelDiagramXMAS"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Usage Example / Hello World! / Vacuum World
\end_layout

\begin_layout Section
iiLang (and xml serialization/deserialization?)
\begin_inset CommandInset label
LatexCommand label
name "sec:iiLang"

\end_inset


\end_layout

\begin_layout Section
Network Streaming
\end_layout

\begin_layout Section
Source code excerpts
\end_layout

\end_body
\end_document
