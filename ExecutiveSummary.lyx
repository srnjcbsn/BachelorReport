#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Organizational Multi-Agent Systems in GOAL
\end_layout

\begin_layout Author
Søren Jacobsen & Jannick Johnsen
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In this executive summary we will document our efforts to design an API
 for creation of MAS (Multi Agent System) environments and a reference implement
ation developed with the GOAL agent programming language.
 The API is written in C# and can be used to control multiple agents acting
 and communicating asynchronously in a world.
 As the API is for designing environments, the agents are supposed to receive
 commands from and send percepts to a seperate agent programming language,
 which implements the artificial intelligence of the agents.
 
\end_layout

\begin_layout Standard
In our reference implementation, we have built a tile based game on top
 of the API, in which agents are controlled by GOAL programs.
 
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
While the EIS standard makes it easy to set up a basic environment capable
 of communicating with certain MAS languages, the user still has to design
 the actual environment and display it.
 Our goal is to provide an engine for designing a world in which agents
 written in any MAS language (GOAL, Jason, etc.) can interact with each other
 as well as the environment.
 Furthermore, we will use the API to develop a world occupied by GOAL agents
 with organizational behaviour.
\end_layout

\begin_layout Section
Reference Implementation
\end_layout

\begin_layout Standard
To showcase and test our engine, we have used it to create a simple environment
 with a tile based world.
 In this world, agents are tasked with finding packages in a maze and dropping
 them at a tile containing a 
\family typewriter
dropzone
\family default
 (see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:maze-scrot"

\end_inset

).
 
\end_layout

\begin_layout Standard
Each agent is controlled by a separate GOAL instance connected to the environmen
t via an EIS environmentin.
 Whenever new percepts are available to an agent, all its current percepts
 are returned to its GOAL instance, which choose an appropriate action.
 The actions available to an agent is listed below.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename TileWorldColoredScrot.png
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An initial configuration of the package grabber scenario.
 
\family typewriter
D
\family default
 (red) marks the dropzone, 
\family typewriter
X
\family default
s (green) are packages, 
\family typewriter
A
\family default
s (black) are agents and 
\family typewriter
W
\family default
s (grey) are walls
\begin_inset CommandInset label
LatexCommand label
name "fig:maze-scrot"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
move(Direction)
\family default
 moves the agent one tile in the specified 
\family typewriter
Direction
\family default
.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
grab
\family default
 removes the package in the same tile as the agent (if any) from the world,
 and marks the agent as carrying a package.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
drop
\family default
 adds a package to the world in the same tile as the agent (if it is carrying
 a package) and marks the agent as not carrying a package.
\end_layout

\begin_layout Standard
Additionally, we plan to implement a messaging action, allowing the agents
 to communicate with each other.
 This is particularly necessary when using GOAL, as the GOAL instances have
 no knowledge of each other and ths cannot use the messaging system built
 into GOAL.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename C:/Users/Søren/report/BachelorReport/sequenceDiagram.png
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
When the EIS method 
\family typewriter
performAction(
\emph on
Action
\emph default
)
\family default
 is called, it sends an XML representation of 
\family typewriter
\emph on
Action
\family default
\emph default
 to the engine over a socket, and immediately returns 
\family typewriter
null
\family default
.
 Next, the GOAL instance begins its percept-action cycle, and calls the
 EIS method 
\family typewriter
getAllPercepts
\family default
, which sends the 
\family typewriter
getAllPercepts
\family default
 action to the engine and 
\family typewriter
read
\family default
s on the socket until the engine has some useful percepts to deliver.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Interface agnosticity
\end_layout

\begin_layout Standard
The focus of the design of the API have been on making it as generic as
 possible, and we have been careful not to tie it to GOAL or EIS.
 
\end_layout

\begin_layout Standard
We have implemented the general concepts of percepts and actions without
 requirements as to what they contain and how they are structured.
 Instead, the designer writes converters, which can transform percepts and
 actions to and from foreign types.
 
\end_layout

\begin_layout Standard
In the same way, we have not implemented a way of displaying the world.
 Instead, we provide classes which can listen to events triggered by the
 world and the entities in it.
 These classes can then be used to produce any desired output.
\end_layout

\begin_layout Section
Virtual World
\end_layout

\begin_layout Standard
An 
\emph on
agent
\emph default
 in the API is an entity capable of performing actions and gathering percepts.
 An 
\emph on
agent controller
\emph default
 is connected to an agent and knows how to receive actions from and send
 percepts to the connected APL.
 The 
\emph on
agent server
\emph default
 is responsible for attaching agents to agent controllers.
\end_layout

\begin_layout Subsection
Execution protocol
\end_layout

\begin_layout Standard
We have designed our API so that all agents have a thread of their own,
 meaning they can perform actions and receive percepts independently of
 other agents' states.
 This allows for a more fluently running game, as agents do not stop and
 start actions in synchronization.
 It also means that the properties of agents can be more fine grained, eg.
 an agent's speed can be given as an integer indicating the milliseconds
 it takes to move from one tile to another (in a tile based world).
 
\end_layout

\begin_layout Standard
When an agent controller receives an action to be executed, its default
 behaviour is to command its associated agent to perform the action, and
 then return immediately.
 When it receives the request to return all percepts, it blocks until the
 agent has some new percepts to be returned.
 This allows us to let the APL backend process any new percepts when for
 example the agent is moving.
 This default behaviour can be overridden if the designer wants to return
 percepts in response to actions.
\end_layout

\begin_layout Subsection
Agents
\end_layout

\begin_layout Standard
In our world each agent will be represented as an entity, It won’t have
 any behavior and function much like a shell or body for the Agent Program
 (AP).
 The AP on the other hand will function much like a brain for the agent
 and will contain all its behaviors and knowledge, but only be able to act
 through the agent and never outside its limitations.
 If, for instance, the AP commanded the agent to go through a wall and if
 the agent does not possess such an ability, it will be prevented from doing
 that.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename OverviewEngineAgentsAI.png
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Overview-AI-Agents-XMAS"

\end_inset

The agents in the engine follow commands given by an AP and return feedback
 such as what they see or hear for the AP to interpret.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename StateDiagramAgentEngineAI.png
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:State-diagram"

\end_inset

State diagram for the acquisition and execution of an agent
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the AP wants to acquire an agent, the basic idea is that it will request
 a certain available agent entity and take control of this entity.
 This will all be done through a manager designed specifically for each
 APL, so that it knows how to handle any special cases.
 After the agent has been acquired, the AI will send a command describing
 which actions it should perform and wait for the agent to perform them.
 This sequence will be repeated until the connection between the agent and
 the AI has been broken.
 
\end_layout

\begin_layout Section
Interfacing with EIS
\end_layout

\begin_layout Standard
All APLs that needs to interact with the world will need an interface designed
 with our API.
 Fortunately, a lot of APLs can use EIS (Environment Interface Standard).
 Since our engine is designed using C# and EIS is implemented in Java, we
 use a local TCP connection between EIS and our engine (see Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Interaction-between-GOAL,"

\end_inset

).
 
\end_layout

\begin_layout Standard
As mentioned, all agents in the API execute asynchronously in their own
 thread.
 GOAL, however, seems to be designed to run all agents sequentially in a
 single thread, which means that if a single agent blocks in the call to
 get all its percepts from the environment (because the environment only
 returns when the agent’s current action is fully performed), no other agents
 can continue execution until the call returns.
 One way to circumvent this is to use 
\emph on
durative actions
\emph default
 (as explained in the GOAL user manual).
 With this method an ongoing action is started through GOAL, and in each
 percept cycle GOAL evaluates whether the agent should continue executing
 the action or choose another.
 The problem with this approach is that we are effectively polling the environme
nt through GOAL; the agent may not have any new information in each percept
 cycle, and it may sit idle, waiting for the next percept cycle when it
 has finished the action.
 
\end_layout

\begin_layout Standard
In order to have a more dynamic, responsive and efficient system, we have
 chosen to launch a GOAL environment for each agent.
 This means that the agents will have to share communicate through the environme
nt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename OverviewOfGoalEISEngine.png
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Interaction-between-GOAL,"

\end_inset

Interaction between GOAL, EIS, and XMAS
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Glossary
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
AP 
\emph on
Agent Program
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
APL 
\emph on
Agent Programming Language
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
EIS 
\emph on
Environment Interface Standard
\emph default
 -- A standard for connecting APs to environments, implemented in Java
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
GOAL An agent programming language
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
MAS 
\emph on
Multi Agent System
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
MVC 
\emph on
Model-View-Controller
\emph default
 -- A common design pattern
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
XMAS 
\emph on
Cross Platform Multi Agent System 
\emph default
-- name of the environment engine
\end_layout

\end_body
\end_document
